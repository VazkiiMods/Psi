{
  "itemGroup.psi": "프사이",
  "psi.desc": "이것은 제4의 벽을 깨는 농담입니다, 즐기십시오.",
  "psimisc.shift_for_info": "\u00a77추가 정보를 보려면 \u00a7bSHIFT\u00a77를 누르십시오.",
  "psimisc.spellmaynotfunctionasintended": "이전 버전의 Psi에서 생성된 마법을 가져오는 것 같습니다. 이 마법에 동작 또는 시퀀스 트릭이 포함되어 있는 경우 마법이 생성되었을 때와 동일한 기능(및 비용)이 보장되지 않습니다.",
  "psimisc.component_type": "\u00a7a구성 요소 종류\u00a77: %s",
  "psimisc.none": "(없음)",
  "psimisc.stats": "능력치들",
  "psimisc.socketing": "소켓팅",
  "psimisc.keybind": "프사이 마스터 키바인드",
  "psimisc.selected": "선택됨",
  "psimisc.spell_selected": "\u00a7d선택된 주문\u00a77: %s",
  "psimisc": "이름:",
  "psimisc.compiled": "컴파일 성공",
  "psimisc.errored": "컴파일 오류",
  "psimisc.weak_cad": "당신의 CAD는 이 주문을 사용하기에 너무 능력치가 낮습니다.",
  "psimisc.canceled_spell": "뭔가가 주문을 걸지 못하게 했어요.",
  "psimisc.cancelled_cad_take": "CAD를 만들 수 없는 무언가가 있습니다.",
  "psimisc.constant": "상수",
  "psimisc.next_page": "다음 패이지",
  "psimisc.prev_page": "이전 페이지",
  "psimisc.config": "구성",
  "psimisc.not_your_programmer": "현재 다른 사람이 이 프로그래머를 사용 중입니다.",
  "psimisc.cant_use_programmer": "당신은 이 장치를 어떻게 사용해야 할 지 잘 모르는 것 같습니다.",
  "psimisc.level_display": "레벨 %d",
  "psimisc.level_info": "레벨 %d - 레벨 포인트: %d",
  "psimisc.level_info_creative": "레벨 %d (크리에이티브) - 레벨 포인트: %d",
  "psimisc.locked": "잠김",
  "psimisc.requirements": "요구 사항",
  "psimisc.learn": "배우기",
  "psimisc.levelup": "레벨 업",
  "psimisc.wip": "프사이 베타 | 최종 버전 아님!",
  "psimisc.bullet_type": "\u00a7b종류\u00a77: %s",
  "psimisc.bullet_cost": "\u00a7b비용 계수\u00a77: %s%%",
  "psimisc.level_up_info1": "1 레벨 포인트를 얻었습니다!",
  "psimisc.level_up_info2": "CAD를 내려놓고 [%s]를 눌러 사용하십시오!",
  "psimisc.import_from_clipboard": "클립보드에서 불러오기",
  "psimisc.export_to_clipboard": "클립보드로 내보내기",
  "psimisc.must_hold_shift": "(SHIFT를 눌러야 함)",
  "psimisc.malformed_json": "불러오기 오류: 기형의 문자열입니다: %s",
  "psimisc.missing_pieces": "불러오기 오류: 불러오는 데 필요한 요소가 존재하지 않습니다.",
  "psimisc.load_prompt": "Load?",
  "psimisc.spectator": "[관전자 모드]",
  "psimisc.multiple_cads": "당신의 인벤토리의 다른 CAD가 주문 사용을 방해하고 있습니다. 당신은 오직 하나의 CAD만 사용할 수 있습니다.",
  "psimisc.provider_mod": "\u00a77애드온: \u00a79%s",
  "psimisc.trick_pattern": "^동작: (.+)$",
  "psimisc.programmer_help": "\u00a7a프로그래머 도움말",
  "psimisc.ctrl_windows": "Ctrl",
  "psimisc.ctrl_mac": "Cmd",
  "psimisc.enter_commit": "기여하려면 Enter를 누르십시오.",
  "psimisc.semicolon_line": "줄바꿈을 위해 ;를 사용하십시오.",
  "psimisc.programmer_coords": "선택됨: [%d, %d] | 커서: [%d, %d]",
  "psimisc.programmer_coords_no_cursor": "선택됨: [%d, %d]",
  "psimisc.name": "이름",
  "psimisc.requiredaddons": "필요한 애드온: ",
  "psimisc.modnotfound": "비설치 모드의 조각 %d을(를) 사용하므로 가져오려고 한 주문 전체를 가져오지는 않습니다.",
  "psimisc.spellonnewerversion": "이 주문은 최신 버전의 Psi에서 생성되었습니다. 의도한 대로 작동하거나 작동하지 않을 수 있습니다.",
  "psi.container.socketable": "소켓",
  "psi.subtitle.bullet_create": "주문 저장됨",
  "psi.subtitle.cad_create": "CAD 조립됨",
  "psi.subtitle.spell_cast": "CAD 주문 시전됨",
  "psi.subtitle.loopcast": "CAD 반복 주문 시전됨",
  "block.psi.cad_assembler": "CAD 조립기",
  "block.psi.programmer": "주문 프로그래머",
  "block.psi.psidust_block": "프사이 가루 블록",
  "block.psi.psimetal_block": "프사이 금속 블록",
  "block.psi.psigem_block": "프사이 보석 블록",
  "block.psi.black_psimetal_plate": "어두운 프사이 금속 판",
  "block.psi.lit_black_psimetal_plate": "어두운 프사이 금속 흐름 판",
  "block.psi.white_psimetal_plate": "밝은 프사이 금속 판",
  "block.psi.lit_white_psimetal_plate": "밝은 프사이 금속 흐름 판",
  "block.psi.ebony_psimetal_block": "흑단 프사이 금속 블록",
  "block.psi.ivory_psimetal_block": "상아 프사이 금속 블록",
  "block.psi.conjured": "소환된 블록",
  "block.psi.psimetal_plate_white": "밝은 프사이 금속 판",
  "block.psi.psimetal_plate_white_light": "밝은 프사이 금속 흐름 판",
  "item.psi.psidust": "프사이 가루",
  "item.psi.psimetal": "프사이 금속 주괴",
  "item.psi.psigem": "Psigem",
  "item.psi.ebony_psimetal": "흑단 프사이 금속 주괴",
  "item.psi.ivory_psimetal": "상아 프사이 금속 주괴",
  "item.psi.ebony_substance": "흑단 물질",
  "item.psi.ivory_substance": "상아 물질",
  "item.psi.cad": "시전 도우미 장치(CAD)",
  "item.psi.cad_assembly_iron": "철 CAD 조립틀",
  "item.psi.cad_assembly_gold": "금 CAD 조립틀",
  "item.psi.cad_assembly_psimetal": "프사이 금속 CAD 조립틀",
  "item.psi.cad_assembly_ebony_psimetal": "흑단 프사이 금속 CAD 조립틀",
  "item.psi.cad_assembly_ivory_psimetal": "상아 프사이 금속 CAD 조립틀",
  "item.psi.cad_assembly_creative": "크리에이티브 CAD 조립틀",
  "item.psi.cad_core_basic": "기본 CAD 코어",
  "item.psi.cad_core_overclocked": "오버클럭된 CAD 코어",
  "item.psi.cad_core_conductive": "전도성 CAD 코어",
  "item.psi.cad_core_hyperclocked": "하이퍼클럭된 CAD 코어",
  "item.psi.cad_core_radiative": "발광하는 CAD 코어",
  "item.psi.cad_socket_basic": "기본 CAD 소켓",
  "item.psi.cad_socket_signaling": "신호 CAD 소켓",
  "item.psi.cad_socket_large": "대형 CAD 소켓",
  "item.psi.cad_socket_transmissive": "전달 가능한 CAD 소켓",
  "item.psi.cad_socket_huge": "초대형 CAD 소켓",
  "item.psi.cad_battery_basic": "기본 CAD 배터리",
  "item.psi.cad_battery_extended": "확장된 CAD 배터리",
  "item.psi.cad_battery_ultradense": "초고밀도 CAD 배터리",
  "item.psi.cad_colorizer_white": "하얀색 CAD 염색제",
  "item.psi.cad_colorizer_orange": "주황색 CAD 염색제",
  "item.psi.cad_colorizer_magenta": "자홍색 CAD 염색제",
  "item.psi.cad_colorizer_light_blue": "하늘색 CAD 염색제",
  "item.psi.cad_colorizer_yellow": "노랑색 CAD 염색제",
  "item.psi.cad_colorizer_lime": "연두색 CAD 염색제",
  "item.psi.cad_colorizer_pink": "분홍색 CAD 염색제",
  "item.psi.cad_colorizer_gray": "회색 CAD 염색제",
  "item.psi.cad_colorizer_light_gray": "회백색 CAD 염색제",
  "item.psi.cad_colorizer_cyan": "청록색 CAD 염색제",
  "item.psi.cad_colorizer_purple": "보라색 CAD 염색제",
  "item.psi.cad_colorizer_blue": "파란색 CAD 염색제",
  "item.psi.cad_colorizer_brown": "갈색 CAD 염색제",
  "item.psi.cad_colorizer_green": "초록색 CAD 염색제",
  "item.psi.cad_colorizer_red": "빨간색 CAD 염색제",
  "item.psi.cad_colorizer_black": "검은색 CAD 염색제",
  "item.psi.cad_colorizer_rainbow": "전역 CAD 염색제",
  "item.psi.cad_colorizer_psi": "프사이 CAD 염색제",
  "item.psi.cad_colorizer_empty": "빈 CAD 염색제",
  "item.psi.spell_bullet": "주문 탄환",
  "item.psi.spell_bullet_active": "프로그램된 주문 탄환",
  "item.psi.spell_bullet_projectile": "발사체형 주문 탄환",
  "item.psi.spell_bullet_projectile_active": "프로그램된 발사체형 주문 탄환",
  "item.psi.spell_bullet_loop": "반복형 주문 탄환",
  "item.psi.spell_bullet_loop_active": "프로그램된 반복형 주문 탄환",
  "item.psi.spell_bullet_circle": "주문 원 탄환",
  "item.psi.spell_bullet_circle_active": "프로그램된 주문 원 탄환",
  "item.psi.spell_bullet_grenade": "수류탄형 주문 탄환",
  "item.psi.spell_bullet_grenade_active": "프로그램된 수류탄형 주문 탄환",
  "item.psi.spell_bullet_charge": "충전형 주문 탄환",
  "item.psi.spell_bullet_charge_active": "프로그램된 충전형 주문 탄환",
  "item.psi.spell_bullet_mine": "지뢰형 주문 탄환",
  "item.psi.spell_bullet_mine_active": "프로그램된 지뢰형 주문 탄환",
  "item.psi.spell_drive": "주문 드라이브",
  "item.psi.psimetal_shovel": "프사이 금속 삽",
  "item.psi.psimetal_pickaxe": "프사이 금속 곡괭이",
  "item.psi.psimetal_axe": "프사이 금속 도끼",
  "item.psi.psimetal_sword": "프사이 금속 검",
  "item.psi.psimetal_shovel.broken": "손상된 프사이 금속 삽",
  "item.psi.psimetal_pickaxe.broken": "손상된 프사이 금속 곡괭이",
  "item.psi.psimetal_axe.broken": "손상된 프사이 금속 도끼",
  "item.psi.psimetal_sword.broken": "손상된 프사이 금속 검",
  "item.psi.detonator": "주문 뇌관",
  "item.psi.psimetal_exosuit_helmet": "프사이 금속 엑소수트 투구",
  "item.psi.psimetal_exosuit_chestplate": "프사이 금속 엑소수트 흉갑",
  "item.psi.psimetal_exosuit_leggings": "프사이 금속 엑소수트 레깅스",
  "item.psi.psimetal_exosuit_boots": "프사이 금속 엑소수트 부츠",
  "item.psi.psimetal_exosuit_helmet.broken": "손상된 프사이 금속 엑소수트 투구",
  "item.psi.psimetal_exosuit_chestplate.broken": "손상된 프사이 금속 엑소수트 흉갑",
  "item.psi.psimetal_exosuit_leggings.broken": "손상된 프사이 금속 엑소수트 레깅스",
  "item.psi.psimetal_exosuit_boots.broken": "손상된 프사이 금속 엑소수트 부츠",
  "item.psi.exosuit_controller": "엑소수트 제어기",
  "item.psi.exosuit_sensor_light": "엑소수트 빛 센서",
  "item.psi.exosuit_sensor_water": "엑소수트 물 센서",
  "item.psi.exosuit_sensor_heat": "엑소수트 열 센서",
  "item.psi.exosuit_sensor_stress": "엑소수트 체력 센서",
  "item.psi.exosuit_sensor_trigger": "엑소수트 뇌관 센서",
  "item.psi.vector_ruler": "벡터 자",
  "death.attack.psi-overload": "%s(이)가 넘쳐 흐른 프사이 에너지에 감전되었습니다.",
  "psi.component.assembly": "조립틀",
  "psi.component.core": "코어",
  "psi.component.socket": "소켓",
  "psi.component.battery": "배터리",
  "psi.component.dye": "염색제",
  "psi.cadstat.efficiency": "효율성",
  "psi.cadstat.potency": "효능",
  "psi.cadstat.complexity": "복잡성",
  "psi.cadstat.projection": "투영",
  "psi.cadstat.bandwidth": "대역폭",
  "psi.cadstat.sockets": "소켓",
  "psi.cadstat.saved_vectors": "저장된 벡터",
  "psi.cadstat.overflow": "과부하",
  "psi.spellstat.complexity": "복잡성",
  "psi.spellstat.complexity.desc": "요소의 개수",
  "psi.spellstat.potency": "효능",
  "psi.spellstat.potency.desc": "주문의 힘",
  "psi.spellstat.cost": "비용",
  "psi.spellstat.cost.desc": "시전 시의 프사이 에너지 비용",
  "psi.spellstat.projection": "투영",
  "psi.spellstat.projection.desc": "동작 요소의 개수",
  "psi.spellstat.bandwidth": "대역폭",
  "psi.spellstat.bandwidth.desc": "주문의 가로/세로 길이 (최대 값)",
  "psi.bullet_type_basic": "일반형",
  "psi.bullet_type_projectile": "발사체형",
  "psi.bullet_type_loopcast": "반복형",
  "psi.bullet_type_circle": "원형",
  "psi.bullet_type_grenade": "수류탄형",
  "psi.bullet_type_charge": "충전형",
  "psi.bullet_type_mine": "지뢰형",
  "psi.event.none": "(이벤트 없음)",
  "psi.event.damage": "\u00a7b이벤트\u00a77: 데미지",
  "psi.event.tick": "\u00a7b이벤트\u00a77: 매 틱",
  "psi.event.jump": "\u00a7b이벤트\u00a77: 점프",
  "psi.event.low_light": "\u00a7b이벤트\u00a77: 낮은 밝기",
  "psi.event.underwater": "\u00a7b이벤트\u00a77: 물 속",
  "psi.event.on_fire": "\u00a7b이벤트\u00a77: 불 속",
  "psi.event.low_hp": "\u00a7b이벤트\u00a77: 낮은 체력",
  "psi.event.spell_detonate": "\u00a7b이벤트\u00a77: 폭파",
  "psi.programmer_reference0": "\u00a7b조작키",
  "psi.programmer_reference1": "요소 제거: \u00a7bDelete",
  "psi.programmer_reference2": "창 초기화: \u00a7b%1$s-Shift-Delete",
  "psi.programmer_reference3": "창 이동: \u00a7b%1$s + 방향키",
  "psi.programmer_reference4": "그리드 회전: \u00a7b%1$s-Shift-Left/Right",
  "psi.programmer_reference5": "수직 그리드 반사: \u00a7b%1$s-Shift-Down",
  "psi.programmer_reference6": "복사/잘라내기/붙여넣기: \u00a7b%1$s-C/%1$s-X/%1$s-V",
  "psi.programmer_reference7": "되돌리기/다시하기: \u00a7b%1$s-Z/%1$s-Y",
  "psi.programmer_reference8": "패널 열기/요소 선택: \u00a7bEnter",
  "psi.programmer_reference9": "매개 변수 설정: \u00a7b숫자 키 + 방향키",
  "psi.programmer_reference10": "주석 설정: \u00a7b%1$s-D",
  "psi.programmer_reference11": "초점 전환: \u00a7bTab",
  "psi.programmer_reference12": "툴팁 표시: \u00a7bAlt",
  "psi.programmer_reference13": "커서 이동: \u00a7b방향키",
  "psi.programmer_reference14": "Imgur로 업로드: \u00a7b%1$s-Shift-Alt-G",
  "psi.programmer_reference15": "Reddit에 공유: \u00a7b%1$s-Shift-Alt-R",
  "psi.programmer_reference16": "",
  "psi.programmer_reference17": "\u00a7b검색 용어",
  "psi.programmer_reference18": "받는 형식: \u00a7bin:(형식)",
  "psi.programmer_reference19": "내보내는 형식: \u00a7bout:(형식)",
  "psi.programmer_reference20": "~로 시작하는 이름: \u00a7b(이름)_",
  "psi.programmer_reference21": "~로 끝나는 이름: \u00a7b_(이름)",
  "psi.programmer_reference22": "모드로부터: \u00a7b@(이름)",
  "psi.spellpiece.selector_caster": "선택: 시전자",
  "psi.spellpiece.selector_caster.desc": "주문을 시전하는 사람을 선택합니다.",
  "psi.spellpiece.selector_focal_point": "선택: 초점",
  "psi.spellpiece.selector_focal_point.desc": "이 주문의 초점의 엔티티를 선택합니다.",
  "psi.spellpiece.selector_nearby_items": "선택: 주위에 있는 아이템",
  "psi.spellpiece.selector_nearby_items.desc": "주어진 위치에서 주위에 있는 아이템들을 선택합니다.",
  "psi.spellpiece.selector_nearby_living": "선택: 주위에 있는 생물체",
  "psi.spellpiece.selector_nearby_living.desc": "주어진 위치에서 주위에 있는 생물체들을 선택합니다.",
  "psi.spellpiece.selector_nearby_enemies": "선택: 주위에 있는 적",
  "psi.spellpiece.selector_nearby_enemies.desc": "주어진 위치에서 주위에 있는 적들을 선택합니다.",
  "psi.spellpiece.selector_nearby_animals": "선택: 주위에 있는 동물",
  "psi.spellpiece.selector_nearby_animals.desc": "주어진 위치에서 주위에 있는 동물들을 선택합니다.",
  "psi.spellpiece.selector_nearby_projectiles": "선택: 주위에 있는 발사체",
  "psi.spellpiece.selector_nearby_projectiles.desc": "주어진 위치에서 주위에 있는 발사체들을 선택합니다.",
  "psi.spellpiece.selector_nearby_smeltables": "선택: 주위에 있는 구울 것",
  "psi.spellpiece.selector_nearby_smeltables.desc": "주어진 위치에서 주위에 있는 구울 수 있는 것들을 선택합니다.",
  "psi.spellpiece.selector_loopcast_index": "선택: 반복 시전 횟수",
  "psi.spellpiece.selector_loopcast_index.desc": "반복 시전 주문이 시전된 횟수를 반환합니다.",
  "psi.spellpiece.selector_block_broken": "선택: 부서진 블록",
  "psi.spellpiece.selector_block_broken.desc": "도구에 의해 부서진 블록을 선택합니다.",
  "psi.spellpiece.selector_block_side_broken": "선택: 부서진 블록 측면",
  "psi.spellpiece.selector_block_side_broken.desc": "도구에 의해 부서진 블록의 측면을 선택합니다.",
  "psi.spellpiece.selector_attack_target": "선택: 대상 공격",
  "psi.spellpiece.selector_attack_target.desc": "대상 공격을 선택합니다.",
  "psi.spellpiece.selector_sneak_status": "선택: 웅크림 여부",
  "psi.spellpiece.selector_sneak_status.desc": "시전자가 웅크리고 있는지를 반환합니다. (웅크렸으면 1, 아니면 0)",
  "psi.spellpiece.selector_time": "선택: 시간",
  "psi.spellpiece.selector_time.desc": "CAD의 내부 시간을 반환합니다. (틱 단위)",
  "psi.spellpiece.selector_attacker": "선택: 공격자",
  "psi.spellpiece.selector_attacker.desc": "시전자를 공격한 엔티티를 선택합니다.",
  "psi.spellpiece.selector_damage_taken": "선택: 입은 데미지",
  "psi.spellpiece.selector_damage_taken.desc": "시전자가 입은 데미지를 반환합니다.",
  "psi.spellpiece.selector_ruler_vector": "선택: 벡터 자",
  "psi.spellpiece.selector_ruler_vector.desc": "벡터 자에 의해 정의된 벡터를 선택합니다.",
  "psi.spellpiece.selector_item_presence": "선택: 아이템 존재",
  "psi.spellpiece.selector_item_presence.desc": "특정 슬롯의 아이템의 존재를 반환합니다.",
  "psi.spellpiece.selector_block_presence": "선택: 블록 존재",
  "psi.spellpiece.selector_block_presence.desc": "해당 위치의 블록의 존재와 고체성을 반환합니다.",
  "psi.spellpiece.selector_saved_vector": "선택: 저장된 벡터",
  "psi.spellpiece.selector_saved_vector.desc": "CAD 메모리에 저장된 벡터를 선택합니다.",
  "psi.spellpiece.selector_eidos_changelog": "선택: 형상 체인지로그",
  "psi.spellpiece.selector_eidos_changelog.desc": "형상 체인지로그에서 위치를 선택합니다.",
  "psi.spellpiece.selector_nearby_charges": "선택: 전하 수",
  "psi.spellpiece.selector_nearby_charges.desc": "주어진 위치에 가까운 전하 수를 선택합니다.",
  "psi.spellpiece.selector_nearby_players": "선택: 주위에 있는 플레이어",
  "psi.spellpiece.selector_nearby_players.desc": "주어진 위치에 가까운 플레이어를 선택합니다.",
  "psi.spellpiece.selector_nearby_vehicles": "선택: 주위에 있는 탈 수 있는 것",
  "psi.spellpiece.selector_nearby_vehicles.desc": "주어진 위치와 가까운 탈 수 있는 엔티티를 선택합니다.",
  "psi.spellpiece.selector_nearby_falling_blocks": "선택: 주위에 떨어지는 블록",
  "psi.spellpiece.selector_nearby_falling_blocks.desc": "주어진 위치 근처의 떨어지는 블록을 선택합니다.",
  "psi.spellpiece.selector_nearby_glowing": "선택: 발광",
  "psi.spellpiece.selector_nearby_glowing.desc": "주어진 위치 근처에서 빛을 내거나 방출하는 엔티티를 선택합니다.",
  "psi.spellpiece.selector_caster_energy": "선택: 시전자 에너지",
  "psi.spellpiece.selector_caster_energy.desc": "시전자의 프사이 에너지 레벨을 선택합니다.",
  "psi.spellpiece.selector_caster_battery": "선택: 시전자 배터리",
  "psi.spellpiece.selector_caster_battery.desc": "시전자의 CAD 배터리 레벨을 선택합니다.",
  "psi.spellpiece.selector_sucession_counter": "선택: 성공 카운터",
  "psi.spellpiece.selector_sucession_counter.desc": "이 갑옷에서 주문이 실행된 횟수를 선택합니다.",
  "psi.spellpiece.selector_is_elytra_flying": "선택: 일리트라 구축",
  "psi.spellpiece.selector_is_elytra_flying.desc": "시전자가 일리트라를 배치했을 경우 1을 반환합니다.",
  "psi.spellpiece.selector_transmission": "선택: 최근 전송",
  "psi.spellpiece.selector_transmission.desc": "지정된 채널에서 이 CAD가 받은 최근 메시지를 가져옵니다.",
  "psi.spellpiece.selector_item_count": "선택: 아이템 개수",
  "psi.spellpiece.selector_item_count.desc": "인벤토리의 아이템 수를 목표 슬롯의 아이템과 동일하게 계산합니다.",
  "psi.spellpiece.selector_tick_time": "선택: 틱 시간",
  "psi.spellpiece.selector_tick_time.desc": "초점 치수에 대한 틱 시간의 평균을 반환합니다.",
  "psi.spellpiece.selector_tps": "선택: TPS",
  "psi.spellpiece.selector_tps.desc": "초점 치수에 대한 초당 틱 평균을 반환합니다.",
  "psi.spellpiece.operator_sum": "연산자: 덧셈",
  "psi.spellpiece.operator_sum.desc": "A + B (+ C)",
  "psi.spellpiece.operator_subtract": "연산자: 뺄셈",
  "psi.spellpiece.operator_subtract.desc": "A - B (- C)",
  "psi.spellpiece.operator_multiply": "연산자: 곱셈",
  "psi.spellpiece.operator_multiply.desc": "A * B (* C)",
  "psi.spellpiece.operator_divide": "연산자: 나눗셈",
  "psi.spellpiece.operator_divide.desc": "A / B",
  "psi.spellpiece.operator_absolute": "연산자: 절대값",
  "psi.spellpiece.operator_absolute.desc": "숫자의 절대값을 반환합니다.",
  "psi.spellpiece.operator_inverse": "연산자: 역수",
  "psi.spellpiece.operator_inverse.desc": "숫자의 역수를 반환합니다.",
  "psi.spellpiece.operator_modulus": "연산자: 나머지",
  "psi.spellpiece.operator_modulus.desc": "A %% B (정수)",
  "psi.spellpiece.operator_integer_divide": "연산자: 정수의 나눗셈",
  "psi.spellpiece.operator_integer_divide.desc": "A / B (정수)",
  "psi.spellpiece.operator_random": "연산자: 임의의 값",
  "psi.spellpiece.operator_random.desc": "하한값(기본값 0)과 지정된 수(제외) 프사이의 임의의 값을 반환합니다.",
  "psi.spellpiece.operator_sin": "연산자: 사인",
  "psi.spellpiece.operator_sin.desc": "sin(A)",
  "psi.spellpiece.operator_cos": "연산자: 코사인",
  "psi.spellpiece.operator_cos.desc": "cos(A)",
  "psi.spellpiece.operator_asin": "연산자: 아크 사인",
  "psi.spellpiece.operator_asin.desc": "arcsin(A)",
  "psi.spellpiece.operator_acos": "연산자: 아크 코사인",
  "psi.spellpiece.operator_acos.desc": "arccos(A)",
  "psi.spellpiece.operator_max": "연산자: 최댓값",
  "psi.spellpiece.operator_max.desc": "주어진 값 중 최댓값을 반환합니다.",
  "psi.spellpiece.operator_min": "연산자: 최솟값",
  "psi.spellpiece.operator_min.desc": "주어진 값 중 최솟값을 반환합니다.",
  "psi.spellpiece.operator_square": "연산자: 제곱",
  "psi.spellpiece.operator_square.desc": "A^2",
  "psi.spellpiece.operator_cube": "연산자: 세제곱",
  "psi.spellpiece.operator_cube.desc": "A^3",
  "psi.spellpiece.operator_power": "연산자: 거듭제곱",
  "psi.spellpiece.operator_power.desc": "A^B",
  "psi.spellpiece.operator_square_root": "연산자: 제곱근",
  "psi.spellpiece.operator_square_root.desc": "sqrt(A)",
  "psi.spellpiece.operator_log": "연산자: 로그",
  "psi.spellpiece.operator_log.desc": "log(A) 또는 logB(A)",
  "psi.spellpiece.operator_ceiling": "연산자: 올림",
  "psi.spellpiece.operator_ceiling.desc": "소수점을 올려 정수로 만듭니다.",
  "psi.spellpiece.operator_floor": "연산자: 내림",
  "psi.spellpiece.operator_floor.desc": "소수점을 내려 정수로 만듭니다.",
  "psi.spellpiece.operator_round": "연산자: 반올림",
  "psi.spellpiece.operator_round.desc": "숫자를 반올림해 정수로 만듭니다.",
  "psi.spellpiece.operator_entity_position": "연산자: 엔티티의 위치",
  "psi.spellpiece.operator_entity_position.desc": "엔티티의 위치를 구합니다.",
  "psi.spellpiece.operator_entity_look": "연산자: 엔티티의 시선",
  "psi.spellpiece.operator_entity_look.desc": "엔티티의 시선 벡터를 구합니다.",
  "psi.spellpiece.operator_entity_motion": "연산자: 엔티티의 움직임",
  "psi.spellpiece.operator_entity_motion.desc": "엔티티의 움직임 벡터를 구합니다.",
  "psi.spellpiece.operator_entity_axial_look": "연산자: 엔티티의 축 시선",
  "psi.spellpiece.operator_entity_axial_look.desc": "축으로 정렬된 엔티티의 시선 벡터를 구합니다.",
  "psi.spellpiece.operator_focused_entity": "연산자: 바라보는 엔티티",
  "psi.spellpiece.operator_focused_entity.desc": "대상 엔티티가 바라보고 있는 엔티티를 반환합니다.",
  "psi.spellpiece.operator_vector_raycast": "연산자: 벡터 광선 추적",
  "psi.spellpiece.operator_vector_raycast.desc": "벡터의 광선을 추적하여 좌표를 반환합니다. (최대 거리: 32)",
  "psi.spellpiece.operator_vector_raycast_axis": "연산자: 벡터 축 광선 추적",
  "psi.spellpiece.operator_vector_raycast_axis.desc": "축을 기준으로 한 벡터 광선 추적 정보를 반환합니다. (최대 거리: 32)",
  "psi.spellpiece.operator_vector_sum": "연산자: 벡터 덧셈",
  "psi.spellpiece.operator_vector_sum.desc": "A + B (+ C)",
  "psi.spellpiece.operator_vector_subtract": "연산자: 벡터 뺄셈",
  "psi.spellpiece.operator_vector_subtract.desc": "A - B (- C)",
  "psi.spellpiece.operator_vector_multiply": "연산자: 벡터 곱셈",
  "psi.spellpiece.operator_vector_multiply.desc": "A * B",
  "psi.spellpiece.operator_vector_divide": "연산자: 벡터 나눗셈",
  "psi.spellpiece.operator_vector_divide.desc": "A / B",
  "psi.spellpiece.operator_vector_cross_product": "연산자: 벡터 가위곱",
  "psi.spellpiece.operator_vector_cross_product.desc": "A x B",
  "psi.spellpiece.operator_vector_normalize": "연산자: 벡터 정규화",
  "psi.spellpiece.operator_vector_normalize.desc": "벡터를 정규화시켜 크기가 1이 되게 합니다.",
  "psi.spellpiece.operator_vector_negate": "연산자: 벡터 부호 변환",
  "psi.spellpiece.operator_vector_negate.desc": "벡터의 부호를 변환합니다.",
  "psi.spellpiece.operator_vector_magnitude": "연산자: 벡터 크기",
  "psi.spellpiece.operator_vector_magnitude.desc": "벡터의 크기를 반환합니다.",
  "psi.spellpiece.operator_vector_construct": "연산자: 벡터 생성",
  "psi.spellpiece.operator_vector_construct.desc": "XYZ 매개 변수를 바탕으로 벡터를 생성합니다.",
  "psi.spellpiece.operator_vector_extract_x": "연산자: 벡터 X 추출",
  "psi.spellpiece.operator_vector_extract_x.desc": "벡터에서 X 좌표를 추출합니다.",
  "psi.spellpiece.operator_vector_extract_y": "연산자: 벡터 Y 추출",
  "psi.spellpiece.operator_vector_extract_y.desc": "벡터에서 Y 좌표를 추출합니다.",
  "psi.spellpiece.operator_vector_extract_z": "연산자: 벡터 Z 추출",
  "psi.spellpiece.operator_vector_extract_z.desc": "벡터에서 Z 좌표를 추출합니다.",
  "psi.spellpiece.operator_vector_project": "연산자: 벡터 투영",
  "psi.spellpiece.operator_vector_project.desc": "벡터 A를 벡터 B에 투영시킵니다.",
  "psi.spellpiece.operator_vector_dot_product": "연산자: 스칼라곱",
  "psi.spellpiece.operator_vector_dot_product.desc": "A . B",
  "psi.spellpiece.operator_closest_to_point": "연산자: 지점에서 가장 가까운 것",
  "psi.spellpiece.operator_closest_to_point.desc": "지점에서 가장 가까운 엔티티를 반환합니다.",
  "psi.spellpiece.operator_random_entity": "연산자: 무작위 엔티티",
  "psi.spellpiece.operator_random_entity.desc": "무작위 엔티티를 반환합니다.",
  "psi.spellpiece.operator_list_add": "연산자: 목록에 추가",
  "psi.spellpiece.operator_list_add.desc": "엔티티를 목록에 추가합니다.",
  "psi.spellpiece.operator_list_remove": "연산자: 목록에서 제거",
  "psi.spellpiece.operator_list_remove.desc": "엔티티를 목록에서 제거합니다.",
  "psi.spellpiece.operator_planar_normal_vector": "연산자: 평면 법선벡터",
  "psi.spellpiece.operator_planar_normal_vector.desc": "지정된 축 벡터에 대한 수직 벡터를 생성합니다. <1,1,1> 주변에서 2\u03c0/3 회전하는 것과 같습니다.",
  "psi.spellpiece.operator_vector_rotate": "연산자: 벡터 회전",
  "psi.spellpiece.operator_vector_rotate.desc": "축을 중심으로 벡터를 회전합니다.",
  "psi.spellpiece.operator_gamma_function": "연산자: 감마 함수",
  "psi.spellpiece.operator_gamma_function.desc": "\u0393(x), (x-1)에 해당합니다!",
  "psi.spellpiece.operator_list_size": "연산자: 목록 크기",
  "psi.spellpiece.operator_list_size.desc": "목록의 엔티티 수를 가져옵니다.",
  "psi.spellpiece.operator_list_union": "연산자: 목록 연결",
  "psi.spellpiece.operator_list_union.desc": "두 목록 중 하나의 모든 아이템으로 목록을 작성합니다.",
  "psi.spellpiece.operator_list_intersection": "연산자: 목록 교차",
  "psi.spellpiece.operator_list_intersection.desc": "두 목록에 있는 모든 아이템으로 목록을 작성합니다.",
  "psi.spellpiece.operator_list_exclusion": "연산자: 목록 제외",
  "psi.spellpiece.operator_list_exclusion.desc": "첫 번째 목록에는 있지만 두 번째 목록에는 없는 모든 아이템으로 목록을 작성합니다.",
  "psi.spellpiece.operator_list_index": "선택: 색인을 단 요소",
  "psi.spellpiece.operator_list_index.desc": "지정된 색인을 가진 엔티티 목록에서 엔티티를 선택합니다.",
  "psi.spellpiece.operator_root": "연산자: 루트",
  "psi.spellpiece.operator_root.desc": "숫자의 n번째 루트를 가져옵니다.",
  "psi.spellpiece.operator_extract_sign": "연산자: 부호 함수",
  "psi.spellpiece.operator_extract_sign.desc": "입력에서 부호를 추출합니다.",
  "psi.spellpiece.operator_vector_extract_sign": "연산자: 벡터",
  "psi.spellpiece.operator_vector_extract_sign.desc": "각 벡터 구성 요소의 해당 기호가 있는 새 벡터를 반환합니다.",
  "psi.spellpiece.operator_closest_to_line": "연산자: 가장 근접한 선",
  "psi.spellpiece.operator_closest_to_line.desc": "선분에 가장 가까운 엔티티를 선택합니다.",
  "psi.spellpiece.operator_entity_health": "연산자: 엔티티 상태",
  "psi.spellpiece.operator_entity_health.desc": "엔티티의 현재 상태 백분율을 가져옵니다.",
  "psi.spellpiece.operator_vector_absolute": "연산자: 벡터 절대값",
  "psi.spellpiece.operator_vector_absolute.desc": "모든 벡터 값의 절대값을 가져오고 새 벡터를 반환합니다.",
  "psi.spellpiece.operator_entity_raycast": "연산자: 엔티티 광선 투사",
  "psi.spellpiece.operator_entity_raycast.desc": "지정된 위치에서 광선 투사하고 찾은 첫 번째 엔티티를 반환합니다.",
  "psi.spellpiece.operator_block_light": "연산자: 블록 밝기",
  "psi.spellpiece.operator_block_light.desc": "블록의 조명 값을 가져옵니다.",
  "psi.spellpiece.operator_block_hardness.desc": "블록의 경도 값을 가져옵니다.",
  "psi.spellpiece.operator_block_hardness": "연산자: 블록 경도",
  "psi.spellpiece.operator_block_comparator_strength": "연산자: 블록 비교기",
  "psi.spellpiece.operator_block_comparator_strength.desc": "블록의 비교기 강도를 가져옵니다.",
  "psi.spellpiece.operator_block_side_solidity": "연산자: 블록 측면 견고성",
  "psi.spellpiece.operator_block_side_solidity.desc": "블록의 측면이 실선인지 여부를 가져옵니다.",
  "psi.spellpiece.operator_block_mining_level": "연산자: 블록 채굴 레벨",
  "psi.spellpiece.operator_block_mining_level.desc": "지정된 위치에서 블록의 채굴 수준을 가져옵니다.",
  "psi.spellpiece.operator_vector_piecewise_maximum": "연산자: 벡터 구분적 최댓값",
  "psi.spellpiece.operator_vector_piecewise_maximum.desc": "입력의 각 구성 요소 중 가장 큰 것으로부터 벡터를 구성합니다.",
  "psi.spellpiece.operator_vector_piecewise_minimum": "연산자: 벡터 구분적 최솟값",
  "psi.spellpiece.operator_vector_piecewise_minimum.desc": "입력의 각 구성 요소 중 가장 작은 것으로부터 벡터를 구성합니다.",
  "psi.spellpiece.operator_entity_height": "연산자: 엔티티 높이",
  "psi.spellpiece.operator_entity_height.desc": "엔티티의 높이를 가져옵니다.",
  "psi.spellpiece.constant_number": "상수: 숫자",
  "psi.spellpiece.constant_number.desc": "값을 설정하려면 선택 후 값을 입력하십시오.",
  "psi.spellpiece.constant_pi": "상수: 원주율(π)",
  "psi.spellpiece.constant_pi.desc": "원주율의 값을 반환합니다.",
  "psi.spellpiece.constant_e": "상수: e",
  "psi.spellpiece.constant_e.desc": "e의 값을 반환합니다.",
  "psi.spellpiece.constant_tau": "상수: 타우(τ)",
  "psi.spellpiece.constant_tau.desc": "타우의 값을 반환합니다.",
  "psi.spellpiece.constant_wrapper": "상수: 변환기",
  "psi.spellpiece.constant_wrapper.desc": "일반 형식의 숫자를 상수 형식으로 변환합니다.",
  "psi.spellpiece.connector": "연결기",
  "psi.spellpiece.connector.desc": "요소들을 잇습니다.",
  "psi.spellpiece.cross_connector": "교차 연결기",
  "psi.spellpiece.cross_connector.desc": "두 경로를 연결할 수 있습니다.",
  "psi.spellpiece.error_suppressor": "오류 억제기",
  "psi.spellpiece.error_suppressor.desc": "주문에 의해 발생한 오류를 진압합니다.",
  "psi.spellpiece.error_catch": "오류 캐처",
  "psi.spellpiece.error_catch.desc": "오류를 다른 값으로 대체합니다.",
  "psi.spellpiece.trick_debug": "동작: 디버그",
  "psi.spellpiece.trick_debug.desc": "테스트 목적. 대상을 출력합니다.",
  "psi.spellpiece.trick_delay": "동작: 미루기",
  "psi.spellpiece.trick_delay.desc": "주어진 틱만큼 실행을 미룹니다.",
  "psi.spellpiece.trick_die": "동작: 죽기",
  "psi.spellpiece.trick_die.desc": "주어진 숫자가 -1과 1 프사이이면 실행을 중단합니다.",
  "psi.spellpiece.trick_evaluate": "동작: 값 구하기",
  "psi.spellpiece.trick_evaluate.desc": "값을 구합니다. 실질적인 작동은 없습니다.",
  "psi.spellpiece.trick_add_motion": "동작: 움직임 추가",
  "psi.spellpiece.trick_add_motion.desc": "대상 엔티티에 움직임을 추가합니다.",
  "psi.spellpiece.trick_explode": "동작: 폭발",
  "psi.spellpiece.trick_explode.desc": "폭발을 일으킵니다.",
  "psi.spellpiece.trick_break_block": "동작: 블록 파괴",
  "psi.spellpiece.trick_break_block.desc": "블록을 부숩니다.",
  "psi.spellpiece.trick_break_in_sequence": "동작: 블록 묶음 파괴",
  "psi.spellpiece.trick_break_in_sequence.desc": "벡터에 의해 정의된 블록 묶음을 부숩니다.",
  "psi.spellpiece.trick_place_block": "동작: 블록 설치",
  "psi.spellpiece.trick_place_block.desc": "블록을 설치합니다.",
  "psi.spellpiece.trick_place_in_sequence": "동작: 블록 묶음 설치",
  "psi.spellpiece.trick_place_in_sequence.desc": "벡터에 의해 정의된 블록 묶음을 설치합니다.",
  "psi.spellpiece.trick_infusion": "동작: 에너지 주입",
  "psi.spellpiece.trick_infusion.desc": "프사이 금속에는 금을, 프사이 가루에는 레드스톤을 주입합니다.",
  "psi.spellpiece.trick_blink": "동작: 점멸",
  "psi.spellpiece.trick_blink.desc": "앞으로 점멸합니다.",
  "psi.spellpiece.trick_mass_blink": "동작: 전체 점멸",
  "psi.spellpiece.trick_mass_blink.desc": "모두 앞으로 점멸합니다.",
  "psi.spellpiece.trick_mass_add_motion": "동작: 전체 움직임 추가",
  "psi.spellpiece.trick_mass_add_motion.desc": "엔티티 목록의 모든 엔티티에 움직임을 추가합니다.",
  "psi.spellpiece.trick_mass_exodus": "동작: 전체 집결",
  "psi.spellpiece.trick_mass_exodus.desc": "엔티티 목록의 모든 엔티티를 지정된 위치로 옮깁니다.",
  "psi.spellpiece.trick_move_block": "동작: 블록 이동",
  "psi.spellpiece.trick_move_block.desc": "축 벡터에 의해 정의된 블록을 옮깁니다.",
  "psi.spellpiece.trick_move_block_sequence": "동작: 블록 묶음 이동",
  "psi.spellpiece.trick_move_block_sequence.desc": "주어진 단위 축 벡터를 따라 블록 묶음을 이동합니다.",
  "psi.spellpiece.trick_collapse_block": "동작: 블록 무너뜨리기",
  "psi.spellpiece.trick_collapse_block.desc": "해당 블록이 모래인 것처럼, 블록을 무너뜨립니다.",
  "psi.spellpiece.trick_smite": "동작: 번개",
  "psi.spellpiece.trick_smite.desc": "지정된 위치에 번개를 발생시킵니다.",
  "psi.spellpiece.trick_blaze": "동작: 화염",
  "psi.spellpiece.trick_blaze.desc": "지정된 위치에 불을 발생시킵니다.",
  "psi.spellpiece.trick_torrent": "동작: 수맥",
  "psi.spellpiece.trick_torrent.desc": "지정된 위치에 물을 발생시킵니다.",
  "psi.spellpiece.trick_overgrow": "동작: 급성장",
  "psi.spellpiece.trick_overgrow.desc": "지정된 위치에 비료를 줍니다.",
  "psi.spellpiece.trick_greater_infusion": "동작: 에너지 대량 주입",
  "psi.spellpiece.trick_greater_infusion.desc": "레드스톤과 금을 주입하는 것처럼 다이아몬드를 프사이 보석에 주입합니다.",
  "psi.spellpiece.trick_ebony_ivory": "동작: 흑단 및 상아",
  "psi.spellpiece.trick_ebony_ivory.desc": "레드스톤, 금, 다이아몬드를 여전히 주입하는 동안 마지막에 석탄과 석영을 주입합니다.",
  "psi.spellpiece.trick_speed": "동작: 신속",
  "psi.spellpiece.trick_speed.desc": "신속 효과를 적용합니다.",
  "psi.spellpiece.trick_haste": "동작: 성급함",
  "psi.spellpiece.trick_haste.desc": "성급함 효과를 적용합니다.",
  "psi.spellpiece.trick_strength": "동작: 힘",
  "psi.spellpiece.trick_strength.desc": "힘 효과를 적용합니다.",
  "psi.spellpiece.trick_jump_boost": "동작: 점프 강화",
  "psi.spellpiece.trick_jump_boost.desc": "점프 강화 효과를 적용합니다.",
  "psi.spellpiece.trick_water_breathing": "동작: 수중 호흡",
  "psi.spellpiece.trick_water_breathing.desc": "수중 호흡 효과를 적용합니다.",
  "psi.spellpiece.trick_fire_resistance": "동작: 화염 저항",
  "psi.spellpiece.trick_fire_resistance.desc": "화염 저항 효과를 적용합니다.",
  "psi.spellpiece.trick_invisibility": "동작: 투명화",
  "psi.spellpiece.trick_invisibility.desc": "투명화 효과를 적용합니다.",
  "psi.spellpiece.trick_regeneration": "동작: 재생",
  "psi.spellpiece.trick_regeneration.desc": "재생 효과를 적용합니다.",
  "psi.spellpiece.trick_resistance": "동작: 저항",
  "psi.spellpiece.trick_resistance.desc": "저항 효과를 적용합니다.",
  "psi.spellpiece.trick_slowness": "동작: 구속",
  "psi.spellpiece.trick_slowness.desc": "구속 효과를 적용합니다.",
  "psi.spellpiece.trick_weakness": "동작: 나약함",
  "psi.spellpiece.trick_weakness.desc": "나약함 효과를 적용합니다.",
  "psi.spellpiece.trick_wither": "동작: 시듦",
  "psi.spellpiece.trick_wither.desc": "시듦 효과를 적용합니다.",
  "psi.spellpiece.trick_ignite": "동작: 불태우기",
  "psi.spellpiece.trick_ignite.desc": "대상 엔티티를 불태웁니다.",
  "psi.spellpiece.trick_eidos_anchor": "동작: 형상의 닻",
  "psi.spellpiece.trick_eidos_anchor.desc": "일정 시간 이후 시전자를 현재 위치로 이동시킵니다.",
  "psi.spellpiece.trick_eidos_reversal": "동작: 형상 회귀",
  "psi.spellpiece.trick_eidos_reversal.desc": "시전자를 일정 시간 전 위치로 이동시킵니다.",
  "psi.spellpiece.trick_smelt_item": "동작: 아이템 제련",
  "psi.spellpiece.trick_smelt_item.desc": "아이템의 엔티티를 제련합니다.",
  "psi.spellpiece.trick_smelt_block": "동작: 블록 제련",
  "psi.spellpiece.trick_smelt_block.desc": "블록을 제련합니다.",
  "psi.spellpiece.trick_conjure_block": "동작: 블록 소환",
  "psi.spellpiece.trick_conjure_block.desc": "주어진 위치에 블록을 소환합니다.",
  "psi.spellpiece.trick_conjure_light": "동작: 광원 소환",
  "psi.spellpiece.trick_conjure_light.desc": "주어진 위치에 광원을 소환합니다.",
  "psi.spellpiece.trick_conjure_block_sequence": "동작: 블록 묶음 소환",
  "psi.spellpiece.trick_conjure_block_sequence.desc": "지정된 벡터를 따라 일련의 취약한 블록을 소환합니다.",
  "psi.spellpiece.trick_switch_target_slot": "동작: 선택 슬롯 변경 (핫바)",
  "psi.spellpiece.trick_switch_target_slot.desc": "이 주문에서 선택된 슬롯을 핫바의 아무 곳으로나 변경합니다.",
  "psi.spellpiece.trick_save_vector": "동작: 벡터 저장",
  "psi.spellpiece.trick_save_vector.desc": "CAD 메모리에 벡터를 저장합니다.",
  "psi.spellpiece.trick_play_sound": "동작: 소리 재생",
  "psi.spellpiece.trick_play_sound.desc": "소리 블록의 소리를 재생합니다.",
  "psi.spellpiece.trick_break_loop": "동작: 반복 멈추기",
  "psi.spellpiece.trick_break_loop.desc": "대상이 (-1,1) 배타적인 경우 반복을 중지합니다.",
  "psi.spellpiece.trick_detonate": "동작: 폭파",
  "psi.spellpiece.trick_detonate.desc": "초점 32개 블록 내에서 모든 주문 전하를 폭파시킵니다.",
  "psi.spellpiece.trick_till": "동작: 경작",
  "psi.spellpiece.trick_till.desc": "블록을 경작합니다.",
  "psi.spellpiece.trick_till_sequence": "동작: 묶음 경작",
  "psi.spellpiece.trick_till_sequence.desc": "주어진 벡터를 따라 일련의 블록을 경작합니다.",
  "psi.spellpiece.trick_broadcast": "동작: 방송",
  "psi.spellpiece.trick_broadcast.desc": "지정된 채널의 숫자를 근처 CAD로 방송합니다.",
  "psi.spellpiece.trick_change_slot": "동작: 슬롯 변경 (인벤토리)",
  "psi.spellpiece.trick_change_slot.desc": "빌딩 슬롯을 36개의 인벤토리 슬롯 중 하나로 변경합니다.",
  "psi.spellpiece.trick_smelt_block_sequence": "동작: 블록 묶음 제련",
  "psi.spellpiece.trick_smelt_block_sequence.desc": "주어진 위치에서 시작하여 정의된 방향으로 블록을 제련합니다.",
  "psi.spellpiece.trick_collapse_block_sequence": "동작: 블록 묶음 무너뜨리기",
  "psi.spellpiece.trick_collapse_block_sequence.desc": "마치 모래처럼 일련의 블록을 무너뜨립니다.",
  "psi.spellpiece.trick_debug_spamless": "동작: 채널형 디버그",
  "psi.spellpiece.trick_debug_spamless.desc": "표적을 인쇄하여 이전의 모든 인쇄물을 동일한 번호로 교체합니다.",
  "psi.spellpiece.trick_night_vision": "동작: 야간 투시",
  "psi.spellpiece.trick_night_vision.desc": "야간 투시 효과를 적용합니다.",
  "psi.spellpiece.trick_particle_trail": "동작: 입자 흔적",
  "psi.spellpiece.trick_particle_trail.desc": "광선을 따라 위치에서 입자 흔적을 만듭니다.",
  "psi.spellpiece.trick_spin_chamber": "동작: 회전원",
  "psi.spellpiece.trick_spin_chamber.desc": "입력 기호에 따라 다음 또는 이전 글머리 기호를 선택합니다.",
  "psi.spellpiece.trick_russian_roulette": "동작: 러시안 룰렛",
  "psi.spellpiece.trick_russian_roulette.desc": "임의의 탄환을 선택합니다.",
  "psi.spellparam.target": "대상",
  "psi.spellparam.number": "숫자",
  "psi.spellparam.root": "루트",
  "psi.spellparam.list1": "목록 A",
  "psi.spellparam.list2": "목록 B",
  "psi.spellparam.list": "목록",
  "psi.spellparam.from1": "에서",
  "psi.spellparam.from2": "에서",
  "psi.spellparam.to1": "까지",
  "psi.spellparam.to2": "까지",
  "psi.spellparam.toggle": "토글",
  "psi.spellparam.number1": "숫자 A",
  "psi.spellparam.number2": "숫자 B",
  "psi.spellparam.number3": "숫자 C",
  "psi.spellparam.number4": "숫자 D",
  "psi.spellparam.vector1": "벡터 A",
  "psi.spellparam.vector2": "벡터 B",
  "psi.spellparam.vector3": "벡터 C",
  "psi.spellparam.vector4": "벡터 D",
  "psi.spellparam.position": "위치",
  "psi.spellparam.ray": "광선",
  "psi.spellparam.max": "최대",
  "psi.spellparam.min": "최소",
  "psi.spellparam.power": "힘",
  "psi.spellparam.direction": "방향",
  "psi.spellparam.speed": "속도",
  "psi.spellparam.x": "X",
  "psi.spellparam.y": "Y",
  "psi.spellparam.z": "Z",
  "psi.spellparam.radius": "범위",
  "psi.spellparam.distance": "거리",
  "psi.spellparam.time": "시간",
  "psi.spellparam.constant": "상수",
  "psi.spellparam.shift": "이동",
  "psi.spellparam.slot": "슬롯",
  "psi.spellparam.base": "기반",
  "psi.spellparam.vector": "벡터",
  "psi.spellparam.axis": "축",
  "psi.spellparam.angle": "각도",
  "psi.spellparam.channel": "채널",
  "psi.spellparam.instrument": "계측기",
  "psi.spellparam.volume": "음량",
  "psi.spellparam.pitch": "음높이",
  "psi.spellparam.mask": "무늬",
  "psi.spellparam.ray_end": "광선 끝",
  "psi.spellparam.ray_start": "광선 시작",
  "psi.spellparam.fallback": "대비책",
  "psi.datatype.void": "없음",
  "psi.datatype.any": "모든 타입",
  "psi.datatype.double": "숫자",
  "psi.datatype.integer": "숫자",
  "psi.datatype.number": "숫자",
  "psi.datatype.vector3": "벡터",
  "psi.datatype.entity": "엔티티",
  "psi.datatype.living_entity": "엔티티 (생물체)",
  "psi.datatype.living_entity_base": "엔티티 (생물체)",
  "psi.datatype.player_entity": "엔티티 (Player, 생물체)",
  "psi.datatype.entity_list_wrapper": "엔티티 목록",
  "psi.spellerror.nan": "오류: 숫자가 아닙니다.",
  "psi.spellerror.nospell": "컴파일할 주문이 없습니다.",
  "psi.spellerror.invalid_base": "오류: 2 미만의 기준을 해석할 수 없습니다.",
  "psi.spellerror.nthroot": "오류: 짝수 루트는 음수를 사용할 수 없습니다.",
  "psi.spellerror.noname": "주문의 이름이 없습니다.",
  "psi.spellerror.notricks": "주문이 동작을 포함하지 않습니다.",
  "psi.spellerror.unsetparam": "필요한 매개 변수가 채워지지 않았습니다.",
  "psi.spellerror.nullparam": "매개 변수가 빈칸을 가리킵니다.",
  "psi.spellerror.invalidparam": "매개 변수가 유효하지 않은 칸을 가리킵니다.",
  "psi.spellerror.samesideparams": "두 개 또는 더 많은 매개 변수가 같은 면을 가리킵니다.",
  "psi.spellerror.loop": "무한 반복을 해결할 수 없습니다.",
  "psi.spellerror.nonpositivevalue": "양수여야 하는 매개 변수가 양수가 아닙니다.",
  "psi.spellerror.noninteger": "정수여야 하는 매개 변수가 정수가 아닙니다.",
  "psi.spellerror.nonpositiveinteger": "양수형 정수여야 하는 매개 변수가 양수형 정수가 아닙니다.",
  "psi.spellerror.statoverflow": "주문의 요구 능력치가 너무 높습니다.",
  "psi.spellerror.exclusiveparams": "두 양립할 수 없는 매개 변수가 설정되었습니다.",
  "psi.spellerror.position": "위치 오류: [%d, %d].",
  "psi.spellerror.dividebyzero": "오류: 0으로 나누어집니다.",
  "psi.spellerror.nulltarget": "오류: 주문의 대상이 존재하지 않습니다.",
  "psi.spellerror.nullvector": "오류: 주문의 벡터가 존재하지 않거나 비어 있습니다.",
  "psi.spellerror.outsideradius": "오류: 주문의 대상이 32블록 범위 밖에 있습니다.",
  "psi.spellerror.outsidetrigdomain": "오류: 값이 역삼각함수의 영역을 벗어납니다.",
  "psi.spellerror.bossimmune": "오류: 면역된 엔티티나 보스 위에 주문을 시전하는 것이 시도되었습니다.",
  "psi.spellerror.nocad": "오류: 시전자가 CAD를 가지고 있지 않습니다.",
  "psi.spellerror.memoryoutofbounds": "오류: 존재하지 않는 메모리 슬롯입니다.",
  "psi.spellerror.lockedmemory": "오류: 메모리 슬롯이 잠겨 있습니다.",
  "psi.spellerror.immunetarget": "오류: 대상 엔티티가 면역된 엔티티이거나 보스입니다.",
  "psi.spellerror.negativenumber": "오류: 음수이면 안 될 대상 숫자가 음수입니다.",
  "psi.spellerror.nonaxial": "오류: 벡터는 비축일 수 없습니다.",
  "psi.spellerror.volume": "오류: 음량은 [0,1] 프사이여야 합니다.",
  "psi.spellerror.instruments": "오류: 계측기 값은 [0,15] 프사이여야 합니다.",
  "psi.spellerror.pitch": "오류: 음높이 값은 [0,24] 프사이여야 합니다.",
  "psi.spellerror.out_of_bounds": "오류: 제공된 색인이 목록의 범위를 벗어났습니다.",
  "psi.levelskip": "Psi가 이전 세계에서 몇 개의 데이터를 찾았습니다.<br>그 데이터를 불러오길 원하시나요?<br><br>당신이 원하신다면, 당신은 즉시 레벨 %d가 될 수 있습니다. 아니라면, 이 메시지는 다시 나타나지 않을 것입니다.",
  "psi.spellerror.armor": "오류: 선택기는 갑옷에서 시전된 경우에만 작동합니다.",
  "psi.spellerror.no_message": "오류: CAD가 방송된 메시지를 선택하지 않았습니다.",
  "psi.spellerror.comparator": "오류: 비교기는 4가지 기본 방향으로만 측정할 수 있습니다.",
  "psi.spellerror.cad_casting_only": "오류: 이 기술은 CAD에서 시전되어야 합니다.",
  "command.psi.learn.usage": "/psi-learn <group> [player]",
  "command.psi.learn.success": "%s과(와) %s을(를) 성공적으로 알려주었습니다.",
  "command.psi.learn.success.all": "%s에 모든 Psi를 성공적으로 알려주었습니다.",
  "command.psi.learn.should_not": "%s이(가) %s을(를) 이미 알고 있습니다.",
  "command.psi.learn.players": "%s은(는) 플레이어가 아니며, 플레이어만 프사이 지식을 가질 수 있습니다.",
  "command.psi.learn.console": "콘솔이 Psi를 학습할 수 없습니다. 플레이어를 지정해 보십시오! /psi-learn <group> [player]",
  "command.psi.learn.not_a_group": "'%s'은(는) 유효한 프사이 조각 그룹이 아닙니다.",
  "command.psi.learn.unknown": "이 플레이어에는 프사이 데이터가 없습니다. 모드 작성자에게 보고하십시오.",
  "command.psi.unlearn.usage": "/psi-unlearn <group> [player]",
  "command.psi.unlearn.success": "%s이(가) %s을(를) 잊게 했습니다.",
  "command.psi.unlearn.success.all": "%s이(가) 모든 Psi를 잊게 했습니다.",
  "command.psi.unlearn.should_not": "%s은(는) %s을(를) 모릅니다.",
  "command.psi.unlearn.players": "%s은(는) 플레이어가 아니며, 플레이어만 프사이 지식을 가질 수 있습니다.",
  "command.psi.unlearn.console": "콘솔이 Psi를 학습할 수 없습니다. 플레이어를 지정해 보십시오! /psi-unlearn <group> [player]",
  "command.psi.unlearn.not_a_group": "'%s'은(는) 유효한 프사이 조각 그룹이 아닙니다.",
  "command.psi.unlearn.unknown": "이 플레이어에는 프사이 데이터가 없습니다. 모드 작성자에게 보고하십시오.",
  "psi.tutorial1": "튜토리얼 1",
  "psi.tutorial2": "튜토리얼 2",
  "psi.tutorial3": "튜토리얼 3",
  "psi.tutorial4": "튜토리얼 4",
  "psi.numbers_intro": "숫자 101",
  "psi.vectors_intro": "벡터 101",
  "psi.entities_intro": "엔티티 101",
  "psi.projectiles": "대안 시전",
  "psi.block_works": "블록 작업",
  "psi.infusion": "프사이 금속 주입",
  "psi.movement": "이동 진전",
  "psi.loopcasting": "반복 시전",
  "psi.block_movement": "블록 이동",
  "psi.elemental_arts": "기초 예술",
  "psi.greater_infusion": "대형 주입",
  "psi.tool_casting": "도구 시전",
  "psi.positive_effects": "긍정적 효과",
  "psi.negative_effects": "부정적 효과",
  "psi.exosuit_casting": "엑소수트 시전",
  "psi.trignometry": "삼각법",
  "psi.smeltery": "제련",
  "psi.flow_control": "흐름 제어",
  "psi.block_conjuration": "블록 소환",
  "psi.eidos_ceversal": "형상 조작",
  "psi.detection_dynamics": "감지 및 초점",
  "psi.memory_management": "메모리 관리",
  "psi.secondary_operators": "보조 연산자",
  "psi.misc_tricks": "기타 동작",
  "psi.list_operations": "목록 연산",
  "psi.fake_level_psidust": "프사이 가루 주입",
  "jei.psi.category.trick": "주문 주입",
  "jei.psi.spell_copy": "주문 복사",
  "psi.subtitle.book": "귀여운 알렉숨은 멀리서 연주해요.",
  "_comment": "Book stuff",
  "advancement.psi:iron_cad_pickup": "달콤한 몸",
  "advancement.psi:iron_cad_pickup.desc": "철 CAD 조립틀 제작",
  "advancement.psi:gold_assembly_pickup": "금으로 된 무게의 가치",
  "advancement.psi:gold_assembly_pickup.desc": "금 CAD 조립틀 제작",
  "advancement.psi:psimetal_assembly_pickup": "Psi스럽게 좋아지다",
  "advancement.psi:psimetal_assembly_pickup.desc": "프사이 금속 CAD 조립틀 제작",
  "advancement.psi:ebony_assembly_pickup": "강하고 두껍게",
  "advancement.psi:ebony_assembly_pickup.desc": "흑단 CAD 조립틀 제작",
  "advancement.psi:ivory_assembly_pickup": "빛나고 요염하게",
  "advancement.psi:ivory_assembly_pickup.desc": "상아 CAD 조립틀 제작",
  "advancement.psi:psidust": "...만들기 어렵다고요?",
  "advancement.psi:psidust.desc": "첫 번째 프사이 가루 조각 제작",
  "advancement.psi:psimetal_pickup": "경외의 합금",
  "advancement.psi:psimetal_pickup.desc": "첫 번째 프사이 금속 조각 주입",
  "advancement.psi:psigem_pickup": "수정을 생각하다",
  "advancement.psi:psigem_pickup.desc": "다이아몬드로 당신의 첫 프사이 보석을 주입하십시오.",
  "advancement.psi:ebony_pickup": "고가치",
  "advancement.psi:ebony_pickup.desc": "석탄에서 첫 흑단 물질 주입",
  "advancement.psi:ivory_pickup": "다른 가치",
  "advancement.psi:ivory_pickup.desc": "석영에서 첫 상아 물질 주입",
  "advancement.psi:encyclopaedia_psionica": "내 태블릿에 저장,
  "advancement.psi:encyclopaedia_psionica.desc": "Psi에 대한 가이드인 프사이 백과사전을 제작",
  "psi.book.subtitle": "주문 101",
  "psi.book.name": "프사이 백과사전",
  "psi.book.landing_text": "$(thing)프사이$(0)는 자신의 독창성에 의해서만 한계가 정의되는 $(thing)주문$(0)을 만드는 방식입니다. 이 책에는 주문 상담 전문가가 되기 위해 필요한 모든 지식이 포함되어 있습니다.$(p)(이 책은 진행 중인 작업입니다. 이전 튜토리얼 항목은 유산 항목 섹션에서 찾을 수 있습니다.)",
  "psi.book.category.basics": "기본 사항",
  "psi.book.category.basics.desc": "당신이 $(thing)프사이$(0)를 처음 접하는 사람이라면 여기 있는 모든 항목을 읽어보시길 권합니다. 모두 중요한 정보를 담고 있습니다.",
  "psi.book.entry.introduction": "소개",
  "psi.book.page.introduction.0": "$(thing)프사이$(0)에 오신 것을 환영합니다! 최고의 주문 프로그램 기반 마법 모드입니다.$(p)$(thing)프사이$(0)는 마법과고교의 열등생 시리즈에서 영감을 받아 주변의 세계에서 $(thing)주문$(0)을 만들고 시전하는 모드입니다.$(p)주문 마법사가 되기 위한 여행을 시작하기 위해서는 먼저 $(l:components/psidust)$(item)프사이 가루$(0)$(/l)가 필요합니다. 하지만 단순히 물건을 만드는 것은 아닙니다.",
  "psi.book.page.introduction.1": "대신 $(l:basics/cad_assembler)$(item)CAD 조립기$(0)$(/l)와 $(l:components/assembly#iron)$(item)철 CAD 조립틀$(0)$(/l)을 제작하는 것으로 시작합니다.$(p)$(l:basics/cad_assembler)$(item)CAD 조립기$(0)$(/l)를 배치하고 연 다음 $(l:components/assembly#iron)$(item)철 CAD 조립틀$(0)$(/l)을 삽입하여 매우 맨뼈인 $(thing)시전 보조 장치$(0)(약칭: $(thing)CAD$(0))를 구성합니다.$(p)거기서 $(item)레드스톤 가루$(0)를 땅에 설치하고 새 $(thing)CAD$(0)를 먼지로 향하게 한 다음 ($(k:use)) 주문하여 $(l:components/psidust)$(item)프사이 가루$(0)$(/l)를 만듭니다.",
  "psi.book.entry.cadAssembler": "CAD 조립기",
  "psi.book.page.cadAssembler.0": "$(item)CAD 조립기$(0)는 $(thing)프사이$(0)의 심장으로서 두 가지 필수 기능을 수행합니다.$(p)첫째, 구성 부품에서 $(thing)CAD$(0)를 조립합니다. 둘째, $(o)비어 있지 않은$() $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)을 $(thing)CAD$(0)에 로드합니다($(l:items/tools)$(thing)프사이 금속 도구$(0)$(/l))와 같은 $(l:items/spell_bullet)$(thing)탄환$(0)$(/l)을 고정하는 다른 것들).",
  "psi.book.page.cadAssembler.1": "CAD 작업장 구축",
  "psi.book.page.cadAssembler.2": "시전할 수 있는 가장 간단한 CAD",
  "psi.book.page.cadAssembler.3": "$(thing)CAD$(0)는 최대 5개의 구성요소로 제작됩니다.; 가장 간단한 $(thing)CAD$(0)는 하나의 구성요소, 즉 $(l:components/assembly)$(thing)조립틀$(0)$(/l)만을 사용합니다. 단, $(l:components/psidust)$(item)프사이 가루$(0)$(/l)를 만드는 데만 유용합니다.$(p)$(thing)주문$(0)을 주조할 수 있는 $(thing)CAD$(0)에는 $(l:components/core)$(thing)코어$(0)$(/l)와 $(l:components/socket)$(thing)소켓$(0)$(/l)도 필요합니다.$(p)$(l:components/battery)$(thing)배터리$(0)$(/l)를 추가하면 사용자의 최대 $(thing)프사이 에너지$(0)가 약간 증가하며, $(l:components/colorizer)$(thing)염색제$(0)$(/l)를 추가하면 순수하게 외관적인 시전 $(thing)주문$(0)의 색상이 바뀝니다.",
  "psi.book.page.cadAssembler.4": "$(thing)CAD$(0)가 작성되면 $(item)CAD 조립기$(0)의 맨 왼쪽 패널에 배치될 수 있습니다.$(p)여기에 배치하면 아래 슬롯이 열립니다.; 이 슬롯에 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)을 배치하여 $(thing)CAD$(0)에 로드할 수 있습니다.$(p)$(l:items/spell_bullet)$(thing)탄환$(0)$(/l)이 로드되고 $(thing)CAD$(0)가 제거되고 보류되며 $(thing)프사이 마스터키 설정$(0)($(k:psimisc.keybind))이 유지되면 the $(l:items/spell_bullet)$(thing)탄환$(0)$(/l)의 $(thing)주문$(0)이 HUD에 표시되고 선택 및 시전 준비가 됩니다.",
  "psi.book.page.cadAssembler.5": "탄환 하나가 장착된 CAD",
  "psi.book.entry.spellProgrammer": "주문 프로그래머",
  "psi.book.page.spellProgrammer.0": "$(l:basics/cad_assembler)$(item)CAD 조립기$(0)$(/l)가 $(thing)프사이$(0)의 심장인 경우 $(item)주문 프로그래머$(0)는 모드의 뇌입니다. $(thing)주문$(0)이 작성되고 컴파일되어 결국 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)로 복사되어 시전되는 곳입니다.$(p)배치하고 열면 ($(k:use)) 대형 9x9 그리드가 표시됩니다.; 이 그리드 사용에 대한 자세한 내용은 $(l:basics/tutorial_1)튜토리얼 항목$(/l)을 참조하십시오.",
  "psi.book.page.spellProgrammer.1": "코드의 시간",
  "psi.book.entry.vectorPrimer": "벡터 입문",
  "psi.book.page.vectorPrimer.0": "$(thing)프사이$(0)는 벡터 개념을 광범위하게 사용합니다. 그러므로 벡터가 무엇인지 전혀 모르신다면 아래 동영상을 꼭 보시기 바랍니다.$(p)다음 몇 페이지의 설명은 초보자를 위해 $(l)단순화$()되었습니다. 확정적으로 받아들이지 마십시오.",
  "psi.book.page.vectorPrimer.1": "$(thing)프사이$(0) 세계(그리고 실제로 $(thing)마인크래프트$(0) 세계)에서, 모든 벡터는 3차원입니다. 본질적으로, 그것들은 단지 세 개의 좌표 목록입니다: $(o)x$(), $(o)y$(), $(o)z$().$(p)$(o)x$() 좌표는 양의 경우 동, 음의 경우 서를 나타내고, $(o)y$()좌표는 위아래, 그리고 $(o)z$()좌표는 남과 북을 나타냅니다.$(p)아직 이해가 되지 않으면 디버그 화면(F3)을 열고 \"XYZ:\"라는 레이블이 지정된 행을 주의하여 돌아다녀야 합니다.$(br)이해하실 겁니다.",
  "psi.book.page.vectorPrimer.2": "디버그 화면에 표시되는 세 개의 숫자 목록은 사실 첫 번째 유형의 벡터입니다: 그건 바로 $(l)위치 벡터$()입니다.$(p)위치 벡터는 단순히 블록, 엔티티 또는 전 세계의 빈 공간의 위치를 나타냅니다. 단일 고정 위치이며 목록 [$(o)x$(), $(o)y$(), $(o)z$()]로 표시됩니다.$(p)그러나 모든 벡터가 위치를 나타내는 것은 아닙니다. 그리고 리스트의 $(l)숫자 세 개가 벡터를 구성합니다$().",
  "psi.book.page.vectorPrimer.3": "벡터에 대한 흥미로운 사실은 벡터가 추가하기가 매우 쉽다는 것입니다.$(p)예를 들어, 어떤 위치에 [$(o)x$(), $(o)y$(), $(o)z$()]로 나타내는 잔디 블록이 있다고 가정해 보겠습니다.$(p)이 값에 다른 벡터(예: [0, 1, 0])를 추가하려면 해당 숫자만 추가하면 됩니다.:$(br)즉, 벡터 합계는 [$(o)x$()+0, $(o)y$()+1, $(o)z$()+0] 또는 [$(o)x$(), $(o)y$()+1, $(o)z$()]가 됩니다.",
  "psi.book.page.vectorPrimer.4": "새로운 벡터의 $(o)y$() 성분은 1씩 증가했고, 양의 $(o)y$()는 상승했기 때문에, 이 새로운 벡터는 단순히 잔디 블록 위의 블록을 나타냅니다.$(p)벡터 [0, 1, 0]는 원래 벡터와 새 벡터 간의 위치 $(o)차이$()를 나타내며, 두 번째 벡터 유형인 $(l)오프셋 벡터$()입니다.",
  "psi.book.page.vectorPrimer.5": "오프셋 벡터는 대부분의 주문들이 대부분의 시간을 조종하는 데 사용하므로, 주문에 대한 숙달은 중요합니다.$(p)일반적으로, 마법사는 단일 위치 벡터로 시작한 다음 오프셋 벡터를 이 위치 벡터와 더하거나 빼거나 조합하여 원하는 점을 세상에서 대상으로 지정합니다.",
  "psi.book.page.vectorPrimer.6": "\"오프셋\" 및 \"위치\" 벡터는 개념적인 개념으로, 이 태블릿의 용어에만 해당됩니다.$(p)다시 말하지만, 모든 $(thing)프사이$(0)벡터는 단지 세 개의 숫자로 이루어진 목록일 뿐이며, 구별이 없는 척하는 것을 막을 수 있는 것은 없습니다.$(p)사실, 이 책의 범위를 벗어난 어떤 맥락에서는, 그 구별이 $(o)말이 되지 않습니다$().",
  "psi.book.page.vectorPrimer.7": "그러나 $(thing)프사이$(0)의 맥락$(o)에서$() 오프셋과 위치 벡터를 배치하면 실제로 예측 불가능한 결과가 발생할 수 있습니다.$(p)두 가지 규칙은 다음과 같습니다.:$(p)$(li)벡터를 사용하는 대부분의 $(thing)연산자$(0)는 위치 벡터를 하나만 사용해야 하며, $(p)$(li)블록에 영향을 미치는 대부분의 $(thing)동작$(0)은 위치 벡터$(o)만$() 사용해야 합니다.$(p)하지만 일반적인 규칙입니다. 일부 $(thing)주문 조각$(0)은 다르게 동작합니다.",
  "psi.book.page.vectorPrimer.8": "오프셋 벡터에는 $(l)크기$()가 있습니다.$(p)오프셋 벡터의 크기는 \"길이,\" 또는 월드 내의 위치 프사이의 거리로 생각할 수 있으며 오프셋 벡터가 이 위치에 추가되었을 때 동일한 위치로 생각할 수 있습니다.$(p)예를 들어, 이전의 오프셋 벡터 [0, 1, 0]은 단순히 위치를 블록 길이만큼 위로 이동시켰기 때문에 길이가 1이고, 따라서 크기가 1입니다.",
  "psi.book.page.vectorPrimer.9": "거리는 항상 양수이므로 벡터의 크기도 양수입니다.$(p)벡터 [0, -3, 0]을 예로 들 수 있습니다. 벡터 [0, -3, 0]은 아래로, 블록 세 개를 나타냅니다. 그러나 이동된 총 거리는 세 블록이며 \"아래쪽\" 비트는 중요하지 않습니다.$(p)따라서 이 벡터의 크기는 $(l)양수$() 3입니다.",
  "psi.book.page.vectorPrimer.10": "크기가 0이 아닌 벡터의 경우 크기를 계산하기가 조금 $(o)어렵습니다$().$(p)그러나 $(o)x$(), $(o)y$(), $(o)z$() 방향이 모두 직각이기 때문에 잘 알려진 피타고라스 정리를 사용하여 벡터의 크기를 계산할 수 있습니다.$(p)특히, 벡터 [$(o)p$(), $(o)q$(), $(o)r$()]의 크기는 숫자 \u221a($(o)p$()\u00b2+$(o)q$()\u00b2+$(o)r$()\u00b2)입니다.",
  "psi.book.page.vectorPrimer.11": "예를 들어, 벡터 [3, -4, 0]의 크기는 정확히 5가 되는 \u221a(3\u00b2+(-4)\u00b2+0\u00b2)입니다.$(p)(대부분 벡터 크기는 정수로 나오지 않습니다.)$(p)위치 벡터의 크기를 $(o)찾을 수$() 있지만 얻을 수 있는 숫자는 대부분 무의미합니다. [0, 0, 0] (기반암과 세계 생성 근처의 임의 지점)으로부터의 거리는 누가 $(o)신경$() 쓰겠습니까?",
  "psi.book.page.vectorPrimer.12": "거의 모든 벡터에도 $(l)방향$()이 있습니다.$(p)오프셋 벡터의 방향은, 음, 만약 그것이 벡터를 따라 일직선으로 움직인다면 어떤 것이 움직이는 방향입니다.$(p)예를 들어, [0, 1, 0]의 방향은 단순히 직선입니다.$(p)반면 벡터 [1, 0, -1]은 동쪽으로 한 블록, 북쪽으로 한 블록을 나타내므로 방향은 북동쪽으로 직진합니다.",
  "psi.book.page.vectorPrimer.13": "(대부분의 방향은 좋지 않습니다. 보통 \"서쪽 36.86도, 수평선 아래 22.62도처럼 보입니다.\")$(p)방향을 가지려면 $(o)다른$() 곳으로 가야 하므로 방향이 없는 유일한 벡터는 [0, 0, 0]($(l)영벡터$())입니다.$(p)위치 벡터의 방향은 그 크기만큼 거의 무의미합니다. 대부분의 $(thing)주문$(0)은 \"세계 생성에서 벗어나려면 어디로 가야 하는지\"알 필요가 없습니다.",
  "psi.book.page.vectorPrimer.14": "실제로, 크기 및 방향만 주어진 벡터를 세 개의 숫자 목록(벡터의 $(l)성분$()이라고 함)으로 재구성할 수 있습니다.$(p)예를 들어 \"윗쪽\" 방향과 크기 1은 벡터 [0, 1, 0]에 해당합니다.$(p)이것은 보이는 것만큼 놀랍지 않습니다:  결국, 만약 누군가가 여러분에게 어느 방향으로 가야 하고, 얼마나 멀리 가야 하는지를 알려준다면, 여러분은 그들이 여러분이 되기를 원한다는 것을 알아야 합니다.",
  "psi.book.page.vectorPrimer.15": "위치 및 오프셋 벡터를 조작하는 몇 가지 간단한 방법이 있습니다.$(p)먼저, 잔디 블록 예제와 같이 위치와 오프셋 벡터를 추가하여 다른 위치 벡터를 얻을 수 있습니다.$(p)반면, 우리는 물론 두 위치 벡터를 $(o)빼서$() 한 값에서 다른 값으로 오프셋을 나타내는 오프셋 벡터를 얻을 수 있습니다:$(br)[$(o)x$(), $(o)y$()+1, $(o)z$()] \u2212 [$(o)x$(), $(o)y$(), $(o)z$()] = [0, 1, 0].",
  "psi.book.page.vectorPrimer.16": "더 흥미로운 것은, 두 개의 오프셋 벡터를 추가하여 이들의 조합을 나타내는 단일 오프셋을 얻을 수 있다는 것입니다.$(p)이 오프셋을 위치 벡터에 추가하는 것은 먼저 해당 구성 요소 중 하나를 해당 위치 벡터에 추가한 다음 다른 구성요소를 추가하는 것과 같습니다.",
  "psi.book.page.vectorPrimer.17": "마지막으로, 가장 중요한 것은 간단한 연산입니다. 벡터에 숫자를 곱하여 벡터를 $(l)확장$() 할 수 있습니다.$(p)다른 벡터가 $(o)아닌$() 숫자로 곱하는 것입니다.$(p)벡터 [$(o)p$(), $(o)q$(), $(o)r$()]에 인자 $(o)n$()을 곱하고자 한다면, 각 벡터의 성분에 $(o)n$():$(br)$(o)n$()\u00b7[$(o)p$(), $(o)q$(), $(o)r$()] = [$(o)n$()\u00b7$(o)p$(), $(o)n$()\u00b7$(o)q$(), $(o)n$()\u00b7$(o)r$()]를 곱하면 됩니다.",
  "psi.book.page.vectorPrimer.18": "이 최종 연산은 크기와 방향의 개념과 정말로 관련이 있습니다.$(p)벡터에 숫자 $(o)n$()을 곱할 때, $(p)$(li)벡터의 크기에 절대값 $(o)n$()을 곱하고, $(p)$(li)$(o)n$()이 양수이면 방향을 바꾸지 않고, $(o)n$()이 음수이면 방향을 반전합니다.$(p)$(o)n$()=0이면 당연히 결과 벡터는 영벡터입니다.",
  "psi.book.page.vectorPrimer.19": "반면, $(o)n$()=-1을 설정하면 -1의 절대값이 1이므로 크기가 같지만 반대 방향(-1이 음수이므로)인 벡터가 생성됩니다.$(p)이 벡터는 원소의 $(l)음수$()라고 알려져 있으며, 둘을 더하면 영벡터가 됩니다.$(p)이것은 말이 됩니다, 왜냐하면 우리가 어떤 방향으로 갔다가 같은 거리를 반대 방향으로 갔다면 우리의 순 이동은 0이 되기 때문입니다.",
  "psi.book.page.vectorPrimer.20": "만약 우리가 (0이 아닌) 벡터를 그 크기로 $(o)나눈다면$(), 우리는 (무엇이든 그 자체로 나눈 것이 1이므로)크기가 1인 벡터를 얻지만 방향은 같습니다(크기는 항상 양수).$(p)이것은 $(l)벡터 정규화$()라고 알려진 중요하고 잘 알려진 연산입니다. 그 결과로 생기는 벡터(사실, 크기가 1인 벡터)를 $(l)단위 벡터$()라고 합니다.",
  "psi.book.page.vectorPrimer.21": "단위 벡터는 크기가 고정되어 있으므로 방향만 나타냅니다.$(p)방향과 관련된 많은 $(thing)주문 조각$(0)은 $(piece)연산자: 벡터 축 광선 추적$(0) 및 $(piece)연산자: 엔티티의 시선$(0)과 같이 단위 벡터를 반환합니다.$(p)실제로, 이 문서에서 설명한 $(o)대부분의$() 벡터 연산을 자가 설명하는 이름으로 수행할 수 있는 $(thing)연산자$(0)가 있습니다.",
  "psi.book.page.vectorPrimer.22": "연산 및 해당 $(thing)연산자$(0)는 다음과 같습니다.$(p)$(li)부정은 $(piece)연산자: 벡터 부정$(0),$(p)$(li)정규화는 $(piece)연산자: 벡터 정규화$(0),$(p)$(li)스케일링은 $(piece)연산자: 벡터 곱셈$(0) 및 $(piece)연산자: 벡터 나눗셈$(0),$(p)$(li)크기는 $(piece)연산자: 벡터 크기$(0),$(p)$(li)더하기는 $(piece)연산자: 벡터 덧셈$(0),$(p)$(li)빼기는 $(piece)연산자: 벡터 뺄셈$(0)입니다.",
  "psi.book.page.vectorPrimer.23": "마지막으로, 벡터는 여전히 세 숫자의 목록입니다. 그것을 놓치지 마십시오.$(p)$(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)에서는 $(piece)연산자: 벡터 생성$(0)을 사용하여 최대 3개의 숫자로 구성할 수 있습니다.$(p)반대로 벡터는 $(piece)연산자: 벡터 X 추출$(0), $(piece)연산자: 벡터 Y 추출$(0), $(piece)연산자: 벡터 Z 추출$(0)을 사용하여 다시 숫자로 나눌 수도 있습니다.",
  "psi.book.page.vectorPrimer.24": "이 튜토리얼을 통과하신 것을 축하드립니다!$(p)다시 말씀드리지만, 이건 벡터에 대한 소개입니다. 저는 점이나 가위곱이나 벡터 투영에 대해 아무 말도 하지 않았습니다.$(p)하지만 이 정도면 꽤 흥미로운 $(thing)주문$(0)을 만들 수 있을 거예요.$(p)그게 다예요. 이제 가서 철자를 외우십시오!",
  "psi.book.entry.tutorial1": "튜토리얼 (1): 주문 작성",
  "psi.book.page.tutorial1.0": "새로운 $(thing)CAD$(0)를 알게 되신 것을 축하드립니다!$(p)이 태블릿은 이 모드의 참조 설명서 역할을 하지만 일부 항목(예: 이 항목)은 자습서로서 적절한 주문 설명서의 개념과 용어를 소개합니다.$(p)걱정마십시오, 이건 가장 긴 튜토리얼이에요, 모든 기본을 다루고 있으니까.",
  "psi.book.page.tutorial1.1": "$(o)$(item)색상$(0) $(piece)텍스트$(0)의 많은 키워드는 링크이며, 각 아이템 또는 개념에 대해 자세히 알아보려면 클릭할 수 있습니다.$()$(p)$(thing)주문$(0) 프로그래밍을 시작하려면 $(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)가 필요합니다.$(p)또한 $(thing)주문$(0)을 실제로 실행하려면 현재 보유하고 있는 것보다 더 나은 $(thing)CAD$(0)가 필요합니다. $(l:basics/cad_assembler)$(item)CAD 조립기$(0)$(/l)에 주문을 구성할 수 있습니다.",
  "psi.book.page.tutorial1.2": "이를 위해 $(l:components/core#basic)$(item)기본 CAD 코어$(0)$(/l)와 $(l:components/socket#basic)$(item)기본 CAD 소켓$(0)$(/l)을 만들 수 있습니다.$(p)다른 $(l:components/assembly)$(thing)조립틀$(0)$(/l)을 만들 필요는 없습니다. 현재 $(thing)CAD$(0)를 제작 그리드에 넣어 하나로 되돌릴 수 있습니다(어쨌든 $(l:components/assembly)$(thing)조립틀$(0)$(/l)일 뿐이죠).$(p)또한 $(thing)주문$(0)은 $(thing)CAD$(0)에서 직접 시전할 수 없습니다. 대신 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)에 저장되므로 구르려면 몇 개의 주문도 필요합니다.",
  "psi.book.page.tutorial1.3": "모든 재료가 수집되면 $(thing)주문$(0) 작성에 대한 표준 작업 흐름은 다음과 같습니다:$(p)$(li)$(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l)에서 $(thing)주문$(0) 구성, $(br)$(li)$(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)로 $(thing)주문$(0) 복사, $(br)$(li)$(l:basics/cad_assembler)$(item)CAD 조립기$(0)$(/l)를 사용하여 $(thing)CAD$(0)로 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l) 로드, $(br)$(li)$(thing)CAD$(0), 포인트 및 캐스트 고정.$(p)이 튜토리얼과 다음 튜토리얼에서는 이 과정을 안내해 드리겠습니다.",
  "psi.book.page.tutorial1.4": "$(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)를 열면 커다란 그리드가 보일 거예요. 여기가 $(thing)주문$(0)이 만들어지는 곳이고 마법이 일어나는 곳이죠.$(p)$(thing)프사이$(0)의 프로그래밍 시스템은 전통적인 복잡한 시스템이 $(o)아닙니다$(). 대신, $(thing)주문$(0)은 순서대로 실행되는 간단한 $(thing)동작$(0)으로 구성됩니다.$(p)모든 모드는 단순히 $(thing)동작$(0)이 원하는 대로 하도록 하는 데 집중합니다.",
  "psi.book.page.tutorial1.5": "$(thing)프사이$(0)의 $(thing)주문$(0)은 모두 $(thing)주문 조각$(0)에서 $(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l)의 그리드에 작성됩니다. 원하는 만큼 많은 종류의 주문을 그리드에 추가할 수 있지만, 모든 $(thing)주문 조각$(0)이 유효한 $(thing)주문$(0)은 아닙니다.$(p)그리드에 조각을 추가하려면 조각을 이동할 위치를 마우스 오른쪽 버튼으로 클릭하고 팝업되는 조각 메뉴에서 선택합니다.",
  "psi.book.page.tutorial1.6": "$(thing)주문 조각$(0)의 메뉴에서 선택하면 하나를 가리키면 이름을 볼 수 있으며, 이름을 클릭하여 그리드에 배치할 수 있습니다.$(p)무수히 많은 항목이 나타날지 염려하지 마십시오. 입력만 하면 특정 항목을 검색할 수 있습니다. Enter 키를 누르면 첫 번째 검색 결과가 나옵니다.$(p)Shift 키를 누른 상태에서 오른쪽 하단의 \"?\" 버튼 위로 마우스를 가져가면 바로 가기의 전체 목록을 볼 수 있습니다.",
  "psi.book.page.tutorial1.7": "먼저 $(piece)동작: 디버그$(0)라는 조각을 그리드의 아무 곳에나 배치합니다.$(p)앞서 언급했듯이, 이와 같은 $(thing)동작$(0)은 세계와 상호작용하는 $(thing)주문 조각$(0)입니다.$(p)이것은 가장 간단한 $(thing)동작$(0)트릭입니다. 모든 것은 채팅에서 말하는 것 뿐입니다. 하지만 $(thing)동작$(0)은 여러분의 $(thing)프사이 에너지$(0)를 사용하여 다양한 작업을 수행할 수 있습니다.",
  "psi.book.page.tutorial1.8": "$(piece)동작: 디버그$(0)에 $(l)인접한$() 그리드 조각을 선택하고 $(piece)선택: 시전자$(0)라는 조각을 배치합니다.$(p)$(thing)선택$(0)은 주변 세계에 대한 정보를 $(thing)주문$(0)에 제공하는 $(thing)주문 조각$(0)입니다.$(p)이 작품은 이 $(thing)주문$(0)의 궁극적인 시전자인 당신을 나타냅니다. 이 작품은 $(thing)주문$(0)의 자연스러운 시작점이므로 자주 사용할 수 있습니다.",
  "psi.book.page.tutorial1.9": "거의 모든 $(thing)주문 조각$(0)에는 작업을 수행할 항목을 알려주는 $(l)매개 변수$()가 필요합니다.$(p)예를 들어, 우리는 $(piece)동작: 디버그$(0)가 채팅으로 무언가를 보낸다는 것을 알고 있습니다. 동작: 디버그의 첫 번째 매개 변수는 동작: 디버그에게 $(o)무엇$()을 말해야 할지 알려줍니다.$(p)$(o)매개 변수에는 $(l)데이터 유형$()$(o)이나 줄여서 $(l)유형$()$(o)도 있지만, 이후 튜토리얼에서는 이러한 유형에 대해 알아보겠습니다.$()",
  "psi.book.page.tutorial1.10": "$(piece)동작: 디버그$(0) 조각을 마우스 왼쪽 버튼으로 클릭하면 패널이 두 줄로 왼쪽에 나타납니다. 각 행에는 레이블과 여러 개의 작은 화살표가 있어야 합니다.$(p)이 두 행은 $(piece)동작: 디버그$(0)가 사용하는 두 매개 변수를 나타냅니다.$(p)지금은 \"Number\"라는 레이블이 붙은 행을 무시합니다. 가운데 점은 선택 사항임을 의미한다는 것만 알아 두십시오. $(thing)주문$(0)이 작동하려면 선택사항이 $(o)아닌$() 모든 매개변수를 채워야 합니다.",
  "psi.book.page.tutorial1.11": "\"대상,\"이라는 레이블이 붙은 화살표를 보고 $(piece)선택: 시전자$(0)를 배치한 위치에 해당하는 화살표를 선택합니다(예: $(piece)동작: 디버그$(0) 오른쪽에 배치한 경우 왼쪽을 가리키는 가장 오른쪽 화살표 선택). 그러면 $(thing)선택$(0) 조각이 $(thing)동작$(0) 조각을 가리키고 있는 것으로 나타납니다.",
  "psi.book.page.tutorial1.12": "이렇게 하면 $(thing)동작$(0)이 $(thing)선택$(0)을 \"대상\" 매개 변수로 사용합니다.$(p)$(piece)동작: 디버그$(0)는 $(piece)선택: 시전자$(0)를 \"대상\" 매개 변수로 $(l)받아들이거나$() $(l)받아들인다고$() 합니다.$(p)매개 변수는 $(l)인수$() 또는 단순 $(l)입력$()이라고도 합니다.$(p)$(o)기술 참고 사항: 프로그래밍과 어휘에는 미묘한 차이가 있지만 이 태블릿의 범위를 벗어납니다.$()",
  "psi.book.page.tutorial1.13": "당신의 마지막 $(thing)주문$(0)은 이렇게 생겼을 것입니다.",
  "psi.book.page.tutorial1.14": "이때 $(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l)의 왼쪽 상단 모서리에 있는 X가 체크 표시로 바뀌어야 합니다.$(p)체크 표시는 $(thing)주문$(0)이 $(l)c성공적으로 컴파일되었음$()을 의미합니다(\"$(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l)는 모든 $(thing)주문 조각$(0)이 올바르게 일치하는지 확인\"이라는 간단한 표현입니다.).",
  "psi.book.page.tutorial1.15": "X가 있는 경우(즉, 컴파일에 $(l)실패하거나$() $(l)오류$()가 있는 경우), X 위에 마우스를 올려 놓으면 $(thing)주문$(0) 문제를 확인하고 문제를 해결할 수 있습니다.$(p)$(thing)주문$(0)이 성공적으로 컴파일되면 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)으로 복사하여 시전할 수 있습니다. 그리고 $(l:basics/tutorial_2)다음 튜토리얼$(/l)에서는 바로 그렇게 할 거예요!",
  "psi.book.entry.tutorial2": "튜토리얼 (2): 주문 시전",
  "psi.book.page.tutorial2.0": "첫 $(thing)주문$(0)을 쓰셨군요! 사실 시전은 몇 가지 단계를 더 거쳐야 할 것 같아요.$(p)먼저, $(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)를 종료하고 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)(지난 튜토리얼에서 준비했어야 합니다.)을 누른 다음 프로그래머에 있는 탄환을 사용 ($(k:use))합니다. 차임벨이 울리고 글머리 기호 이름이 \"디버그\"로 바뀝니다.",
  "psi.book.page.tutorial2.1": "탄환에는 사용자가 작성한 $(thing)주문$(0)이 포함되며 $(thing)CAD$(0)에 로드될 준비가 되었습니다.$(p)$(thing)CAD$(0)에 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)을 로드하려면 $(l:basics/cad_assembler)$(item)CAD 조립기$(0)$(/l)를 열고 $(thing)CAD$(0)를 맨 왼쪽 슬롯에 삽입합니다. 아래에 있는 슬롯 중 일부가 열려야 합니다. 이 슬롯 중 하나에 작성한 $(thing)주문$(0)이 포함된 탄환을 넣으십시오. $(thing)CAD$(0)를 다시 꺼내십시오.",
  "psi.book.page.tutorial2.2": "$(thing)CAD$(0)는 여러 개의 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)과 여러 개의 $(thing)주문$(0)을 보유할 수 있으며, 활성된 $(thing)주문$(0) 시전은 즉시 전환될 수 있습니다.$(p)시전할 $(thing)주문$(0)을 선택하려면 $(thing)CAD$(0)를 양손으로 잡고 $(thing)프사이 마스터 키바인드$(0)($(k:psimisc.keybind))를 누르고 있습니다.$(p)HUD가 나타납니다. 방금 작성한 \"디버그\"로 표시된 $(thing)주문$(0)위에 마우스를 놓고 키를 놓으면 해당 키를 선택할 수 있습니다.",
  "psi.book.page.tutorial2.3": "$(thing)주문$(0) ($(k:use))을 시전할 때 사용자 이름과 좌표가 포함된 긴 텍스트 블록이 채팅에 표시됩니다. 그렇다면: 축하합니다! 첫 $(thing)주문$(0)을 쓰고 시전했습니다!$(p)더 많은 $(l:components/psidust)$(item)프사이 가루$(0)$(/l)를 제작해야 하는 경우 HUD를 다시 열고 $(thing)주문$(0)이 저장되지 않은 슬롯을 선택한 다음 평소와 같이 $(item)레드스톤 가루$(0)에서 시전하십시오.",
  "psi.book.page.tutorial2.4": "$(l)참고: 한 번에 하나의 $(thing)CAD$(0)만 휴대해야 합니다.$()$(p)둘 이상 챙기면 $(thing)프사이$(0) 에너지가 간섭하여 $(thing)주문$(0) 시전을 단락시킵니다. \"시전 걸림,\"으로 알려진 이러한 현상은 단순히 이미지당 하나의 $(thing)CAD$(0)로 유지하는 것이 가장 좋습니다.$(p)디버그 $(thing)주문$(0)을 성공적으로 시전했으면 $(l:basics/tutorial_3)다음 튜토리얼$(/l)로 이동할 수 있습니다.",
  "psi.book.entry.tutorial3": "튜토리얼 (3): 유형과 숫자",
  "psi.book.page.tutorial3.0": "$(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)를 열고 \"디버그\" $(thing)주문$(0)을 다시 확인하십시오.$(p)$(l:basics/tutorial_1)첫번째 튜토리얼$(/l)에서 본 $(piece)동작: 디버그$(0)의 \"숫자\" 매개 변수를 기억하십니까? 앞에서 해당 매개 변수는 중앙에 추가 점이 있으므로 비활성화할 수 있다고 언급했습니다. 하지만 이번에는, 그것을 비활성화하지 $(o)않을 것$()입니다.",
  "psi.book.page.tutorial3.1": "$(piece)동작: 디버그$(0)의 \"숫자\" 매개 변수는 사용할 때 여러 종류의 레이블로 인쇄되므로 복잡한 $(thing)주문$(0)에서 $(piece)동작: 디버그$(0)의 여러 사본을 구별할 수 있습니다.$(p)이 매개 변수의 $(l)유형$()은 \"숫자\"입니다. 이는 매개 변수가 숫자를 출력(또는 $(l)반환$()))하는 인수만 허용함을 의미합니다.$(p)첫번째 매개 변수인 \"대상\"은 특수 유형 \"모든 타입\"을 사용할 수 있으며, 이는 무엇이든 허용할 수 있음을 의미합니다.",
  "psi.book.page.tutorial3.2": "Shift 키를 누른 상태에서 주문 조각 위로 마우스를 가져가면 출력 유형뿐만 아니라 모든 매개 변수의 유형도 표시됩니다. 예를 들어 $(piece)선택: 시전자$(0) 조각이 숫자가 아닌 엔티티를 반환하는 것을 볼 수 있습니다. 그래서 우리는 하나를 대표할 다른 조각이 필요합니다.",
  "psi.book.page.tutorial3.3": "$(piece)선택: 시전자$(0) 설명: 시전자, 엔티티를 반환합니다",
  "psi.book.page.tutorial3.4": "$(piece)동작: 디버그$(0) 옆에 있는 빈 그리드 조각을 선택하고 $(piece)상수: 숫자$(0)라는 조각을 배치합니다.$(p)이 조각 위로 Shift-hover를 수행하면 숫자가 $(o)반환$()됩니다(실제로 숫자 상수, 즉 숫자가 반환되지만 더 구체적입니다.).$(p)따라서 $(piece)동작: 디버그$(0)를 다시 마우스 왼쪽 버튼으로 클릭하고 숫자 매개 변수를 $(piece)상수: 숫자$(0)에 지정하면 $(thing)주문$(0)이 컴파일됩니다.",
  "psi.book.page.tutorial3.5": "새롭고 개선된 디버그 $(thing)주문$(0)을 실행하려면 탄환 언로드, $(thing)주문$(0) 재복사, 탄환 재로드 및 $(thing)주문$(0) 재선택이 필요하다고 생각할 수 있습니다.$(p)다행히 $(thing)CAD$(0)에는 바로 가기가 있습니다. 즉, $(thing)CAD$(0)가 웅크린 상태에서 디버그 $(thing)주문$(0)을 선택하고 ($(k:use)) $(thing)CAD$(0)를 $(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l)위에 대면 해당 탄환에 저장된 $(thing)주문$(0)이 $(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l)버전으로 업데이트됩니다.",
  "psi.book.page.tutorial3.6": "지금 디버그 $(thing)주문$(0)을 시전하면 전과 같은 긴 텍스트 블록이 나타나지만 앞에 괄호로 묶인 0이 표시됩니다. 실제로 $(piece)상수: 숫자$(0)에 표시된 0이 있습니다. 이는 배치했을 때 번호입니다.$(p)그러면 다음 질문은 다음과 같습니다. 0이 아닌 $(o)다른$() 숫자를 어떻게 표시합니까?",
  "psi.book.page.tutorial3.7": "글쎄요, $(piece)상수: 숫자$(0) 조각은 특별합니다. 저장된 상수를 설정하려면 조각을 선택하고 새 숫자를 입력하면 됩니다.$(p)다른 모든 $(thing)주문 조각$(0)은 왼쪽 매개 변수 패널에서만 구성됩니다.$(p)$(o)기술적 방법: 모든 숫자 상수가 숫자로 계산되지만 일반 숫자는 숫자 상수로 계산되지 않습니다. $(thing)상수$(0) $(thing)주문 조각$(0)만 숫자 상수를 반환합니다.$()",
  "psi.book.page.tutorial3.8": "$(piece)상수: 숫자$(0)에 저장된 숫자를 편집해 보십시오. 숫자, $(thing)CAD$(0)에 저장된 $(thing)주문$(0) 업데이트 및 재시전입니다. 접두사 번호가 변경된 것을 보셔야 합니다! 깔끔해요!",
  "psi.book.page.tutorial3.9": "이제 중요한 것은 $(piece)동작: 디버그$(0)를 한 번에 최대 두 개의 서로 다른 입력으로 연결했다는 것입니다.$(p)사실 $(o)대부분의$() $(thing)주문 조각$(0)은 두 번(또는 세 번) 입력을 받습니다. 그리고 결국엔, 당신의 $(thing)주문$(0) 입력이 서로 인접하게 될 수도 있습니다.$(p)그게 바로 $(piece)연결기$(0)가 필요한 부분입니다.",
  "psi.book.page.tutorial3.10": "연결기는 단순하지만 강력합니다. 그들은 어떤 유형이든 하나의 입력을 받고 동일한 입력을 반환합니다. 따라서 특정 $(thing)주문 조각$(0)이 입력으로 필요한 경우 두 개의 그리드 공간 거리에 있는 다른 조각을 $(piece)연결기$(0)와 연결할 수 있습니다.",
  "psi.book.page.tutorial3.11": "테라비시아로 가는 다리",
  "psi.book.page.tutorial3.12": "물론 $(piece)연결기$(0)의 진정한 강점은 $(o)서로$() 연결할 수 있다는 것입니다. 따라서 원하는 만큼 먼 곳에서 서로 데이지 체인으로 연결하여 $(thing)주문 조각$(0)을 연결할 수 있습니다.$(p)일부 $(piece)연결기$(0)를 가지고 놀고, 연결기가 마음에 드는 대로 $(l:basics/tutorial_5)다음 튜토리얼$(/l)로 넘어갈 수 있습니다!",
  "psi.book.page.tutorial3.13": "먼 길을 돌아야",
  "psi.book.entry.tutorial4": "튜토리얼 (4): 서둘러라!",
  "psi.book.page.tutorial4.0": "알았어요, 알았어요 네가 무슨 생각하는지 알아요: \"지루해요. 우리 언제부터 멋있는 거 해요?\" 자... 지금요!$(p)세상과 실제로 상호작용하는 $(thing)동작$(0)을 소개하겠습니다: $(piece)동작: 움직임 추가$(0).$(p)이 $(thing)동작$(0)은 엔티티를 가져와서 특정 방향으로 움직임을 추가합니다(즉, 밀어넣기).",
  "psi.book.page.tutorial4.1": "예를 들어 시전자인 당신, 닭, 좀비, 마인카트, 떨어지는 모래 블록, 화살, 위더 등이 있습니다.$(p)이 $(thing)동작$(0)은 엔티티(이동할 엔티티를 나타냄), 벡터(밀어넣기 방향) 및 숫자 상수($(thing)동작$(0)이 엔티티를 얼마나 세게 밀어넣어야 하는지)의 매개 변수로 사용됩니다.$(p)$(o)참고: \"벡터\"라는 단어가 무엇을 의미하는지 잘 모를 경우 $(l:basics/vector_primer)이 항목$(/l)이 좋은 소개가 되어야 합니다.$()",
  "psi.book.page.tutorial4.2": "시전 시 $(piece)동작: 움직임 추가$(0)을 사용하여 시전자를 앞으로 올리는 $(thing)주문$(0)을 작성해 보겠습니다.$(p)앞서 언급한 것처럼 $(piece)선택: 시전자$(0)는 엔티티(즉, 시전자)를 반환하므로, 이 엔티티를 $(piece)동작: 움직임 추가$(0)에 대한 첫 번째 매개 변수로 사용할 수 있습니다.$(p)$(thing)동작$(0)이 당신을 $(o)앞으로$() 나아가게 하고 싶어요. $(o)당신이 보고 있는 방향으로요$(). 그러기 위해 다음 조각을 소개하겠습니다: $(piece)연산자: 엔티티의 시선$(0).",
  "psi.book.page.tutorial4.3": 어떤
  $(thing)연산자$(0)
  조각도
  주변의
  세계를
  어떤
  식으로든
  변화시키지
  않으며
  일부
  예외를
  제외하고는
  정보를
  수집하지도
  않습니다.
  대신,
  그들은
  단지
  정보를
  더
  유용한
  형태로
  $(o)변환$()합니다.$(p)특히
  $(piece)연산자: 엔티티의
  시선$(0)은
  엔티티를
  수락하고
  단위
  벡터(엔티티가
  보고
  있는
  방향)를
  반환합니다.$(p)따라서,
  $(piece)선택: 시전자$(0)에
  연결된
  이들
  중
  하나가
  여러분이
  보고
  있는
  모든
  곳을
  가리키는
  벡터를
  반환합니다.
  ",
  "psi.book.page.tutorial4.4": "마지막으로, $(piece)동작: 움직임 추가$(0)의 마지막 매개 변수를 위해 간단한 $(piece)상수: 숫자$(0)가 할 것입니다.$(p)이 $(thing)주문$(0)을 모두 함께 적용해 보겠습니다: 먼저 $(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)를 열고 현재 프로그래머에 있는 $(thing)주문$(0)을 삭제하십시오. 그런 다음, $(piece)동작: 움직임 추가$(0)를 그리드 근처에 놓습니다.",
  "psi.book.page.tutorial4.5": "$(piece)선택: 시전자$(0)를 $(thing)동작$(0) 바로 위에 배치하십시오. $(piece)연산자: 엔티티의 시선$(0)은 오른쪽을 보고 $(piece)상수: 숫자$(0)를 표시합니다. 왼쪽에 숫자가 있습니다.$(p)$(thing)상수$(0) 값을 입력합니다(숫자 3을 권장합니다).$(p)$(thing)연산자$(0)와 $(thing)"
  선택$(0)
  사이에
  $(piece)연결기$(0)를
  배치한
  후
  $(thing)주문$(0)이
  컴파일되도록
  $(thing)연산자$(0)와
  $(thing)동작$(0)에
  대한
  모든
  매개
  변수를
  설정합니다.
  그러면
  다음
  페이지의
  이미지처럼
  표시됩니다.
  ",
  "psi.book.page.tutorial4.6": "밀어넣기를 시작할 때",
  "psi.book.page.tutorial4.7": "$(thing)CAD$(0)에 $(thing)주문$(0)을 복사하여 정면을 보고 시전하십시오. 만약 여러분이 앞으로 나가게 된다면, 축하합니다! 첫 번째 실제 $(thing)주문$(0)작성을 마쳤습니다!$(p)$(o)참고: 새로운 $(thing)주문$(0)을 연속으로 너무 많이 하면 건강에 좋지 않을 수 있습니다. 이에 대한 자세한 내용은 $(l:basics/tutorial_5)다음 튜토리얼$(/l)에서 확인할 수 있습니다.$()",
  "psi.book.entry.tutorial5": "튜토리얼 (5): 한계",
  "psi.book.page.tutorial5.0": "$(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)를 다시 열고 $(l:basics/tutorial_4)지난 튜토리얼$(/l)에서 작성한 $(thing)주문$(0)을 검토합니다.$(p)올바르게 컴파일되면 그리드 오른쪽에 각각 두 개의 숫자가 있는 5개의 아이콘이 나타납니다.  이 수치 통계는 정확히 어떤 $(thing)주문$(0)을 시전할 수 있는지에 대한 실제 한계를 정의합니다.",
  "psi.book.page.tutorial5.1": "움직임 추가 $(thing)주문$(0)에 대한 통계(상수가 3이라고 가정)",
  "psi.book.subsec.tutorial5.2": "복잡성",
  "psi.book.page.tutorial5.2": "첫번째 통계인 $(thing)복잡성$(0), $(thing)연산자$(0), $(thing)선택$(0), $(thing)주문$(0)에 포함된 디버그가 아닌 $(thing)동작$(0)을 합한 수 입니다.$(p)최댓값은 설치한 $(l:components/core)$(thing)CAD 코어$(0)$(/l)에 따라 결정됩니다; $(thing)주문$(0)의 $(thing)복잡성$(0)이 $(thing)CAD$(0)의 용량을 초과할 경우 시전할 수 없습니다.",
  "psi.book.subsec.tutorial5.3": "효능",
  "psi.book.page.tutorial5.3": "두번째 통계인 $(l:components/assembly)$(thing)조립틀$(0)$(/l) 구성 요소에 의해 상한선이 설정된 $(thing)효능$(0)입니다; $(thing)주문$(0)에 사용된 모든 $(thing)동작$(0)의 대략적인 총 전력 소모량입니다.$(p)일부 $(thing)동작$(0)은 사용당 $(thing)효능$(0) 비용이 고정되어 있습니다. 그러나 상수: 숫자 유형의 매개변수가 있는 대부분의 $(thing)동작$(0)은 상수: 숫자 유형의 매개변수를 사용하여 $(thing)효능$(0)을 결정합니다; 상수가 클수록 $(thing)효능$(0)은 커집니다.",
  "psi.book.subsec.tutorial5.4": "비용",
  "psi.book.page.tutorial5.4": "세번째 통계인 $(thing)비용$(0)은 $(thing)CAD$(0)에서 제한을 설정하지 않는다는 점에서 독특합니다. 대신 $(thing)주문$(0) 이 실행될 때마다 몸의 $(thing)프사이 에너지$(0)에서 $(thing)비용$(0)이 소비됩니다.$(p)표시된 첫 번째 숫자는 $(o)이상적인$() $(thing)주문$(0) $(thing)비용$(0)입니다 -- 모든 $(l:components/assembly)$(thing)CAD 조립틀$(0)$(/l)에는 주문 비용을 증가시키는 결함이 있습니다.",
  "psi.book.page.tutorial5.5": "$(thing)CAD$(0)를 사용한 시전 $(thing)비용$(0)은 $(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l) 디스플레이에 괄호 안에 들어 있는 숫자이며, $(l:components/assembly)$(thing)조립틀$(0)$(/l)의 $(thing)효율성$(0)이 높을수록 $(thing)CAD$(0)의 실제 시전 $(thing)비용$(0)에 더 가깝습니다.",
  "psi.book.page.tutorial5.6": "초당 약 500 유닛의 $(thing)프사이 에너지$(0)가 재생성되므로 $(thing)주문$(0)을 외울 수 있는 속도가 제한됩니다.$(p)현재 $(thing)프사이 에너지$(0)의 레벨은 $(piece)선택: 시전자 에너지$(0)로 $(thing)주문$(0) 내에서 접근할 수 있습니다.",
  "psi.book.page.tutorial5.7": "충분한 $(thing)프사이 에너지$(0) 없이 $(thing)주문$(0)을 외우면($(l)초과인출$()로 알려져 있음), $(thing)CAD$(0)는 자신의 건강에서 초과 비용을 끌어와 $(thing)프사이 에너지$(0)가 완전히 재생성될 때까지 즉시 자체 기능을 비활성화하여 보호를 받게 됩니다.$(p)$(thing)CAD$(0)에 추가된 $(l:components/battery)$(thing)배터리$(0)$(/l)는 이러한 현상을 방지할 수 있습니다.$(p)조심하십시오-- 너무 많이 뽑으면 고통스럽고 어쩌면 치명적일 수도 있어요!",
  "psi.book.subsec.tutorial5.8": "투영",
  "psi.book.page.tutorial5.8": "$(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l)에 표시되는 네 번째 통계는 $(thing)투영$(0)으로 $(thing)주문$(0)에 포함된 디버그를 제외한 총 $(thing)동작$(0) 수입니다.$(p)$(thing)CAD$(0)의 $(l:components/core)$(thing)코어$(0)$(/l)에 따라 $(thing)주문$(0) 당 최대 $(thing)투영$(0)이 결정됩니다; 너무 많은 $(thing)동작$(0)과 $(thing)주문$(0)은 시전할 수 없습니다.",
  "psi.book.subsec.tutorial5.9": "대역폭",
  "psi.book.page.tutorial5.9": "그리고 다섯 번째이자 마지막 통계는 $(thing)대역폭$(0)입니다. 대역폭은 $(l:components/socket)$(thing)CAD 소켓$(0)$(/l)에 의해 상한선이 정해집니다: 그리드 공간에서 측정한 $(thing)주문$(0)의 너비나 높이 중 어느 것이든 더 큽니다.$(p)이것은, 약간의 독창성을 가지고, 작업하기에 더 흥미로운 통계 중 하나입니다; 만약 당신의 $(thing)주문$(0)이 너무 크다면, 어떤 조각들을 이리저리 움직이고 다른 조각들을 제거해서 더 작은 공간에 담는 기술을 $(l)압축$()이라고 합니다.",
  "psi.book.page.tutorial5.10": "$(thing)주문$(0)에 대한 마지막 한 가지 제한이 있습니다: 어떤 $(thing)동작$(0)도 $(l:items/spell_bullet#focal_point)$(thing)초점$(0)$(/l)으로부터 32블록 이상 떨어진 어떤 것에도 영향을 미칠 수 없습니다(평범한 $(l:items/basic_bullet)$(item)주문 탄환$(0)$(/l)의 경우, 그것은 당신, 시전자입니다.), $(thing)주문$(0)의 시전자 자신을 제외하고요.$(p)이렇게 시도하는 $(thing)주문$(0)은 채팅에서 오류를 표시한 후 $(l)흐지부지$()됩니다.$(p)$(thing)주문$(0)이 흐지부지되면 저장된 $(thing)프사이 에너지$(0)를 해치지 않게 분산시키며, 그렇지 않으면 실행할 수 있는 남은 $(thing)주문$(0)은 발생하지 않습니다.",
  "psi.book.page.tutorial5.11": "앞서 언급한 예외를 명확히 하기 위해 다음과 같이 언급했습니다:$(br)특정 유형의 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)에는 시전자가 $(o)아닌$() $(l:items/spell_bullet#focal_point)$(thing)초점$(0)$(/l)이 있습니다-- 그러나 이러한 경우 저장된 $(thing)주문$(0)은 $(l:items/spell_bullet#focal_point)$(thing)초점$(0)$(/l)이 아무리 멀리 떨어져 있더라도 $(piece)선택: 시전자$(0)를 통해 시전자에 영향을 미칠 수 있습니다.$(p)여기 $(l:basics/tutorial_6)마지막 튜토리얼$(/l)이 있습니다. 우리가 배운 대부분의 것을 함께 나열하고 나서 여러분을 더 넓은 $(thing)프사이$(0)의 세계로 안내할 것입니다. 행운을 빌어요!",
  "psi.book.entry.tutorial6": "튜토리얼 (6): 폭발",
  "psi.book.page.tutorial6.0": "혹시 폭발을 좋아하나요?$(p)천만의 말씀이죠. 대부분의 사람들은 폭발을 좋아합니다!$(p)그러면 시전할 때 보고 있는 모든 것을 날려버리는 $(thing)주문$(0)을 만들어 보겠습니다.$(p)무엇이 잘못될 수 있을까요?",
  "psi.book.page.tutorial6.1": "이 $(thing)주문$(0)을 작성하기 위해 폭발을 일으키는 $(thing)동작$(0)부터 시작하여 거꾸로 작업해 보겠습니다.$(p)편리하게도, 이름은 $(piece)동작: 폭발$(0)입니다-- $(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)를 열고, 그리드를 제거한 다음, $(piece)동작: 폭발$(0)을 가운데에 놓습니다.$(p)위쪽으로 이동하면 벡터와 숫자 상수를 매개 변수로 받아들인다는 것을 알 수 있습니다.",
  "psi.book.page.tutorial6.2": "숫자 상수 매개 변수는 폭발의 위력을 나타내며, $(piece)상수: 숫자$(0)으로 채울 수 있을 만큼 쉽습니다.$(p)반면, 벡터는 폭발이 일어날 위치의 위치 벡터를 받아들입니다. 이것이 계산하는데 좀 더 많은 노력이 필요할 것입니다.",
  "psi.book.page.tutorial6.3": "$(l:basics/tutorial_5)지난 튜토리얼$(/l)에서는 $(piece)연산자: 엔티티의 시선$(0)을 사용했습니다.$(p)그러나 해당 $(thing)연산자$(0)는 단위 벡터를 반환하고, $(piece)동작: 폭발$(0)은 위치가 필요하므로 $(thing)동작$(0)에 해당 조각을 직접 공급하면 원하는 결과가 나오지 않을 수 있습니다.$(p)이제 다른 $(thing)연산자$(0)를 소개합니다. 즉, $(piece)연산자: 엔티티의 위치$(0)입니다.",
  "psi.book.page.tutorial6.4": "$(piece)연산자: 엔티티의 위치$(0)는 $(thing)주문$(0))의 시전자와 같은 엔티티를 받아들이고 엔티티의 위치를 반환합니다(정확하게 말하면 여러분과 같은 플레이어의 경우 눈높이에서 사용자의 위치를 반환합니다).$(p)하지만, 우리는 이것을 $(piece)동작: 폭발$(0)로 바로 넘기고 싶지도 않습니다-- 왜냐하면 시전할 때 문자 그대로 여러분의 얼굴에서 폭발할 것이기 때문입니다.",
  "psi.book.page.tutorial6.5": "여기서 우리가 $(o)할 수$() 있는 것은 단순히 $(piece)연산자: 엔티티의 시선$(0) 에서 얻은 벡터를 10의 배수로 확장한 다음, 이것을 $(piece)연산자: 엔티티의 위치$(0)의 출력에 더하는 것입니다.$(p)$(piece)동작: 폭발$(0)에 주입하면 $(thing)주문$(0)을 만들 수 있습니다. 주문을 시전하면 $(o)정확히 열 블록 떨어진 곳에서 여러분이 보고 있는 방향으로 폭발을 일으킬 수 있습니다$().",
  "psi.book.page.tutorial6.6": "하지만 이 $(thing)주문$(0)의 한계는 분명해 보입니다: 만약 여러분이 더 가깝거나 더 멀리 떨어져 있는 무언가를 폭파하고 싶다면, 여러분은 어색한 이동과 거리 계산을 해야 할 것입니다.$(p)모든 것을 고려해 볼 때 그다지 실용적이지 않습니다.$(p)대신, 더 똑똑한 $(piece)연산자: 벡터 광선 추적$(0)을 사용하겠습니다.",
  "psi.book.page.tutorial6.7": "이 $(thing)연산자$(0)의 함수는 직관적으로 간단합니다; 위치 벡터와 \"광선\" 벡터(방향을 나타내는 벡터일 뿐)를 사용할 수 있습니다.$(p)그것의 수익률은 \"만약 내가 그곳에 서서 그 방향을 바라본다면, 내가 어떤 위치를 바라볼 것인가?\"를 꽤 잘 나타내므로 우리의 목적에 딱 맞습니다.$(p)\"최대\" 인수 기능을 포함한 자세한 내용은 $(piece)연산자: 벡터 광선 추적$(0) 관련 페이지를 참조하십시오.",
  "psi.book.page.tutorial6.8": "자! 이 $(thing)주문$(0)을 작성하기 위해 거꾸로 공부해 보겠습니다.$(p)아직 그렇게 하지 않았다면, $(piece)상수: 숫자$(0)를 $(piece)동작: 폭발$(0) 근처에 두십시오($(l:basics/tutorial_1)첫 번째 튜토리얼$(/l)에서 작성한 $(thing)CAD$(0)를 사용 중인 경우 1.4로 설정하는 것이 좋습니다).$(p)그런 다음 $(thing)동작$(0) 옆에 $(piece)연산자: 벡터 광선 추적$(0)도 놓고 $(thing)동작$(0)을 다른 $(thing)주문 조각$(0) 2개까지 연결합니다.",
  "psi.book.page.tutorial6.9": "다음으로, $(piece)연산자: 엔티티의 위치$(0)와 $(piece)연산자: 엔티티의 시선$(0)을 놓고, $(piece)연산자: 벡터 광선 추적$(0)을 그 둘에 연결합니다.$(p)\"위치\"가 엔티티의 위치에 연결되고 \"광선\"이 엔티티의 시선에 연결되었는지 확인하십시오. 그렇지 않으면 $(thing)주문$(0)을 작성할 때 이상한 결과 또는 오차가 발생합니다.$(p)마지막으로 $(piece)선택: 시전자$(0)를 배치하고 이를 두 엔티티 $(thing)연산자$(0)에 연결합니다.",
  "psi.book.page.tutorial6.10": "이 선들을 따라 뭔가",
  "psi.book.page.tutorial6.11": "$(thing)주문$(0)이 성공적으로 컴파일되면 $(thing)CAD$(0)에 주문 내용을 넣고, 주의 깊게 겨냥하고(가급적 별로 신경 쓰지 않는 주문) 시전하십시오.$(p)지금 보고 있는 것이 폭발한다면 잠시 시간을 내어 새로워진 힘을 음미해 보십시오.$(p)그냥, 어, 너무 무리하지 마십시오.",
  "psi.book.page.tutorial6.12": "마지막 한 가지만요: 32블록 이상 떨어진 곳(하늘과 같이 아무것도 없는 곳)에 새로운 \"폭발\" $(thing)주문$(0)을 걸어 보십시오.$(p)폭발을 볼 수 없으며 채팅에서 \"$(c)주문 대상이 최대 32블록 반경 밖에 있습니다.$(0)\"라는 오류가 표시되어야 합니다(이 제한은 마지막 튜토리얼에서 논의되었습니다).$(p)채팅에서 이러한 오류가 발생하면 오히려 성가시게 될 수 있습니다.",
  "psi.book.page.tutorial6.13": "이 문제를 해결하려면 그리드의 아무 곳에나 $(piece)오류 억제기$(0) 조각을 배치하면 결과적으로 발생하는 $(thing)주문$(0)이 대신 시전될 때 자동으로 실패합니다.$(p)디버깅할 때 조각을 제거할 수도 있습니다. 오류는 때때로 $(o)유용할 수$() 있습니다.",
  "psi.book.page.tutorial6.14": "이상으로 튜토리얼의 공부를 마치겠습니다!$(p)이 모드로 정확히 무엇을 할 수 있는지에 대한 아이디어를 위해 이 책의 나머지 부분을 읽어보십시오. 노련한 학자들은 결국 무서운 일을 할 수 있습니다.$(p)$(thing)CAD$(0)와 $(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)로 실험하고 자신만의 $(thing)주문$(0)을 만드는 것은 여러분에게 달려 있습니다.$(p)행운을 빌고, 넓은 $(thing)프사이$(0)의 세계에 오신 것을 환영합니다!",
  "psi.book.entry.evalOrder": "평가 순서",
  "psi.book.page.evalOrder.0": "거의 모든 $(thing)동작$(0)이 포함된 $(thing)주문$(0)과 동시에 실행됩니다. 그럼에도 불구하고 $(piece)흐름 제어 동작$(0)을 사용하려면 평가 순서, 즉 $(thing)주문 조각$(0)이 평가되는 순서에 대한 기본 지식이 필요합니다.",
  "psi.book.page.evalOrder.1": "평가 순서에는 세 가지 기본 규칙이 있습니다; 이 규칙은 다음 페이지에 자세히 설명되어 있지만 간략한 요약은 다음과 같습니다:$(p)$(li)$(thing)주문$(0)이 실행될 때 $(thing)동작$(0)은 각각 왼쪽에서 오른쪽으로, 그리고 위에서 아래로 평가됩니다;$(p)$(li)평가되는 모든 $(thing)주문 조각$(0)은 모든 입력을 먼저 평가합니다;$(p)$(li)$(thing)주문 조각$(0)은 값이 처음 필요할 때 $(thing)주문$(0) 실행당 최대 한 번 평가됩니다.",
  "psi.book.page.evalOrder.2": "첫 번째 규칙은 좀 더 명확하게 설명해야 합니다: 그리드에 더 높게 배치된 $(thing)동작$(0)은 더 낮게 배치된 $(thing)동작$(0)보다 더 일찍 실행되며, 두 개 이상의 $(thing)동작$(0)이 같은 행에 있을 때 맨 왼쪽에 있는 트릭이 먼저 실행됩니다.$(p)따라서 다음 페이지에 표시된 $(thing)주문$(0)은 \"1.0\", \"2.0\", \"3.0\", 및 \"4.0\"을 채팅에 정확한 순서로 표시해야 합니다.",
  "psi.book.page.evalOrder.3": "세보게 만들기",
  "psi.book.page.evalOrder.4": "두 번째 규칙은 간단합니다; $(thing)주문 조각$(0)은 값이 필요할 때만 평가됩니다.$(p)그러나 특히 그 반대도 $(o)마찬가지$()입니다-- 즉, 직접 또는 간접적으로 $(thing)동작$(0)에 $(thing)주문 조각$(0)이 필요하지 $(o)않으면$() $(thing)주문$(0)이 실행될 때 평가되지 않습니다.$(p)$(thing)동작$(0)에 연결되지 않은 $(thing)주문 조각$(0)은 $(l)정의되지 않은 동작$()을 유발합니다-- 이러한 경우 $(thing)주문$(0) 동작에 대한 보장이 없습니다.",
  "psi.book.page.evalOrder.5": "제안되지 않음",
  "psi.book.page.evalOrder.6": "세 번째이자 마지막 규칙은 좀 더 미묘하며 다음 페이지의 $(thing)주문$(0)에 가장 잘 설명되어 있습니다:$(p)$(thing)주문 조각$(0)은 한 번만 평가하고 이후 평가에 대해 $(o)정확히 동일한 값$()을 반환합니다. 따라서 $(piece)연산자: 임의의 값$(0)은 한 번만 평가되므로 표시된 $(piece)동작: 디버그$(0)의 4개 복사본은 모두 $(o)동일한$() 숫자를 출력합니다.$(p)$(piece)동작: 값 구하기$(0)를 사용하여 $(thing)주문 조각$(0)을 \"조기\"에 평가할 수 있습니다.",
  "psi.book.page.evalOrder.7": "선입선출(FIFO=FCFS)",
  "psi.book.category.components": "재료 및 구성요소",
  "psi.book.category.components.desc": "이 책의 이 섹션에는 $(thing)프사이$(0)가 게임에 추가하는 모든 새로운 원재료와 적절한 $(thing)CAD$(0) 구성에 필요한 모든 구성 요소가 자세히 설명되어 있습니다.",
  "psi.book.entry.psidust": "프사이 가루",
  "psi.book.page.psidust.0": "$(item)프사이 가루$(0)는 $(thing)프사이 에너지$(0)의 집중되지 않은 폭발에 의해 $(item)레드스톤 가루$(0)로부터 전달되는 물질이며, 따라서, 해당 에너지의 좋은 전도체입니다.$(p)따라서 단순한 $(l:components/core#basic)$(thing)CAD 코어$(0)$(/l), $(l:components/socket#basic)$(thing)소켓$(0)$(/l), 및 $(l:components/battery#basic)$(thing)배터리$(0)$(/l)뿐만 아니라 모든 $(l:components/colorizer)$(thing)CAD 염색제$(0)$(/l)에서 사용되기 때문에 하위 계층 $(thing)CAD$(0)에서 중요한 구성 요소입니다.$(p)$(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)에도 사용됩니다.",
  "psi.book.page.psidust.1": "$(item)프사이 가루$(0)를 만들려면 먼저 바닥에 $(item)레드스톤 가루$(0)를 던지십시오.$(p)그런 다음 근처에 서서 $(l)$(thing)주문$(0)이 선택되지 않은$() $(thing)CAD$(0)로 주조하여($(k:use)) 레드스톤을 $(item)프사이 가루$(0)로 변환합니다.$(p)$(item)프사이 가루$(0)는 또한 $(piece)주입 동작$(0)을 사용하여 생성할 수 있습니다.",
  "psi.book.entry.psimetal": "프사이 금속",
  "psi.book.page.psimetal.0": "$(item)프사이 금속$(0)은 $(thing)프사이 에너지$(0)를 $(l:components/psidust)$(item)프사이 가루$(0)$(/l)보다 $(o)훨씬 더$() 잘 전도, 저장 및 전달하는 $(item)금 주괴$(0)에서 변환된 물질입니다.$(p)더 강력한 $(l:components/core)$(thing)CAD 코어$(0)$(/l), $(l:components/socket)$(thing)소켓$(0)$(/l) 및 $(l:components/battery#extended)$(thing)배터리$(0)$(/l)의 구성 요소일 뿐만 아니라 우수한 $(l:components/assembly#psimetal)$(thing)CAD 조립틀$(0)$(/l)로 구성할 수 있습니다. 그것은 $(l:components/ebony_ivory)$(item)흑단 및 상아 주괴$(0)$(/l)뿐만 아니라 $(l:items/tools)$(thing)프사이 금속 도구$(0)$(/l)와 $(l:items/exosuit)$(thing)갑옷$(0)$(/l)을 만드는 데도 사용됩니다.",
  "psi.book.page.psimetal.1": "$(item)프사이 금속$(0)을 만들려면 먼저 $(item)금 주괴$(0)를 땅에 떨어뜨려야 합니다.$(p)그런 다음 근처에 서서 $(thing)동작$(0)의 하나로서 $(piece)동작: 에너지 주입$(0)(또는 다른 $(piece)주입 동작$(0))으로 $(thing)주문$(0)을 걸어 금을 $(item)프사이 금속$(0)으로 변환합니다.",
  "psi.book.entry.psigem": "프사이 보석",
  "psi.book.page.psigem.0": "$(item)프사이 보석$(0)은 굴절 특성이 $(thing)프사이 에너지$(0)를 전도, 전달, 저장하는 데 탁월하게 좋은 $(item)다이아몬드$(0)로부터 전송된 수정입니다.$(p)이 부품은 최고급 $(l:components/core)$(thing)CAD 코어$(0)$(/l), $(l:components/socket)$(thing)소켓$(0)$(/l) 및 $(l:components/battery#ultradense)$(thing)배터리$(0)$(/l)를 제작하고 $(l:items/tools)$(thing)프사이 금속 도구$(0)$(/l) 및 $(l:items/exosuit)$(thing)갑옷$(0)$(/l)의 필수 구성 요소로 사용됩니다.",
  "psi.book.page.psigem.1": "$(item)프사이 보석$(0)을 만들려면 먼저 $(item)다이아몬드$(0)를 바닥에 던집니다.$(p)그런 다음, 근처에 서서 $(item)다이아몬드$(0)를 $(item)프사이 보석$(0)으로 바꾸는 동작 중 하나로 $(piece)동작: 에너지 대량 주입$(0)(또는 $(piece)동작: 흑단 및 상아$(0))와 함께 $(thing)주문$(0)을 외우십시오.",
  "psi.book.entry.ebonyIvory": "흑단 및 상아",
  "psi.book.page.ebonyIvory.0": "$(thing)엔드$(0)는 $(thing)오버월드$(0)보다 마음의 차원에 훨씬 가깝습니다. 따라서, 그것의 본질은 마음에서 비롯되는 $(thing)프사이 에너지$(0)에 훨씬 더 전도성이 있습니다.$(p)$(piece)동작: 흑단 및 상아$(0)는 $(item)석탄$(0)과 $(item)네더 석영$(0)에서 이러한 에센스를 포착하여 각각 $(item)흑단 물질$(0)과 $(item)상아 물질$(0)로 변환하는 데 사용될 수 있습니다.",
  "psi.book.page.ebonyIvory.1": "불행하게도, 밝혀진 바와 같이, $(item)흑단$(0)이나 $(item)상아 물질$(0) 어느 쪽도 $(thing)오버월드$(0) 재료와 잘 어울리지 않습니다.$(p)즉, $(l:components/core)$(thing)CAD 코어$(0)$(/l), $(l:components/socket)$(thing)소켓$(0)$(/l), 및 $(l:components/battery)$(thing)배터리$(0)$(/l)로 만드는 것이 다소 어렵다는 것을 의미합니다.$(p)그러나 $(l:components/psimetal)$(item)사이 금속 주괴$(0)$(/l)를 코팅하여 각각 $(item)흑단$(0) 및 $(item)상아 사이 금속 주괴$(0)를 만들 $(o)수$() 있습니다. 이 제품은 $(l:components/assembly)$(thing)CAD 조립틀$(0)$(/l)로 만들 수 있을 정도로 안정적입니다.",
  "psi.book.page.ebonyIvory.2": "$(item)흑단 물질$(0)을 만들려면, 먼저 $(thing)엔드$(0)를 여행하고 $(item)석탄$(0)을 땅에 떨어뜨리십시오.$(p)그런 다음, 근처에 서서 $(item)석탄$(0)을 $(item)흑단 물질$(0)로 바꾸는 $(thing)동작$(0) 중 하나로 $(piece)동작: 흑단 및 상아$(0)와 함께 $(thing)주문$(0)을 외우십시오.",
  "psi.book.page.ebonyIvory.3": "$(item)상아 물질$(0)을 만들려면, 먼저 $(thing)엔드$(0)를 여행하고 $(item)네더 석영$(0)을 땅에 떨어뜨리십시오.$(p)그런 다음, 근처에 서서 $(item)네더 석영$(0)을 $(item)상아 물질$(0)로 바꾸는 $(thing)동작$(0) 중 하나로 $(piece)동작: 흑단 및 상아$(0)와 함께 $(thing)주문$(0)을 외우십시오.",
  "psi.book.page.ebonyIvory.4": "어둠의 치매 까마귀 길",
  "psi.book.page.ebonyIvory.5": "어떤 코끼리도 그것의 창조에서 다치지 않았습니다.",
  "psi.book.entry.assembly": "조립틀",
  "psi.book.page.assembly.0": "$(thing)CAD 조립틀$(0)은 구조가 단순하지만 $(thing)CAD$(0)에서 가장 중요한 단일 구성요소입니다.$(p)$(thing)조립틀$(0)은 사용자의 $(thing)프사이 에너지$(0)를 전달하는 역할을 합니다-- 단순히 작업을 위한 편리한 모양의 회로일 뿐입니다.$(p)모든 $(thing)프사이$(0) $(thing)CAD$(0)는 측면 L자 모양으로 제작 그리드에 있는 구성 요소 재료의 4개의 주괴로 제작됩니다.$(p)",
  "psi.book.page.assembly.1": "$(thing)조립틀$(0)은 $(l:basics/cad_assembler)$(item)CAD 조립기$(0)$(/l)에 꼭 필요한 유일한 $(thing)CAD$(0) 구성요소입니다-- 실제로 $(thing)조립틀$(0) 하나로 구성된 모든 $(thing)CAD$(0)는 그리드의 조립틀로 되돌릴 수 있습니다.$(p)모든 $(thing)조립틀$(0)은 대략적으로 $(thing)프사이 에너지$(0)를 전송할 수 있는 최대 속도인 $(l:basics/tutorial_5#potency)$(thing)효능$(0)$(/l)이 있습니다.$(p)또한 사용자의 $(thing)프사이 에너지$(0)의 백분율인 $(l:basics/tutorial_5#cost)$(thing)효율성$(0)$(/l)을 $(thing)주문$(0)에 따라 $(o)사용$()할 수 있으므로 $(l:basics/tutorial_5#cost)$(thing)효율성$(0)$(/l)이 높을수록 좋습니다.",
  "psi.book.page.assembly.2": "보잘것없는 $(item)철 CAD 조립틀$(0)은 이 책에 서술된 $(thing)조립틀$(0) 중에서 가장 낮은 $(l:basics/tutorial_5#potency)$(thing)효능$(0)$(/l)과 $(l:basics/tutorial_5#cost)$(thing)효율성$(0)$(/l)을 가지고 있습니다.$(p)하지만 상대적으로 저렴하고 다른 $(thing)CAD$(0)와 마찬가지로 $(l:components/psidust)$(item)프사이 가루$(0)$(/l)를 제작합니다. 그래서 초보자들을 위한 $(thing)조립틀$(0)입니다.",
  "psi.book.page.assembly.3": "날렵하고 심플합니다.",
  "psi.book.page.assembly.4": "$(item)금 CAD 조립틀$(0)은 철 CAD 조립틀보다 높은 $(l:basics/tutorial_5#potency)$(thing)효능$(0)$(/l)과 높은 $(l:basics/tutorial_5#cost)$(thing)효율성$(0)$(/l)을 자랑합니다-- 사실, 일반 재료로 만든 $(thing)조립틀$(0) 중 최고입니다.",
  "psi.book.page.assembly.5": "하지만 들고 다니기에는 좀 무거워요.",
  "psi.book.page.assembly.6": "$(item)프사이 금속 CAD 조립틀$(0)은 $(l:components/assembly#iron)$(item)철 CAD 조립틀$(0)$(/l)보다 높은 $(l:basics/tutorial_5#cost)$(thing)효율성$(0)$(/l)과 $(l:components/assembly#gold)$(item)금 CAD 조립틀$(0)$(/l)보다 높은 $(l:basics/tutorial_5#potency)$(thing)효능$(0)$(/l)을 가지고 있어 실제로 다용도입니다.$(p)$(piece)동작: 에너지 대량 주입$(0)과 $(piece)동작: 흑단 및 상아$(0) 모두 주조하려면 이 구경 이상의 $(thing)조립틀$(0)을 가진 $(thing)CAD$(0)가 필요합니다.",
  "psi.book.page.assembly.7": "두 가지 장점을 모두 갖추고 있습니다.",
  "psi.book.page.assembly.8": "$(item)흑단 프사이 금속 CAD 조립틀$(0)은 $(item)조립틀$(0)의 최상위 유형입니다.$(p)$(l:basics/tutorial_5#potency)$(thing)효율성$(0)$(/l)이 약간 떨어지지만 $(l:components/assembly#ivory)$(item)상아$(0)$(/l) 조립틀보다 효능이 좋습니다.",
  "psi.book.page.assembly.9": "말하자면 거물급입니다.",
  "psi.book.page.assembly.10": "$(item)상아 프사이 금속 CAD 조립틀$(0)은 $(item)조립틀$(0)의 최상위 유형입니다.$(p)$(l:components/assembly#ebony)$(item)흑단$(0)$(/l) 조립틀보다 성능은 약간 떨어지지만 $(l:basics/tutorial_5#cost)$(thing)효율성$(0)$(/l)이 뛰어납니다.",
  "psi.book.page.assembly.11": "흐름에 맡깁니다.",
  "psi.book.entry.core": "코어",
  "psi.book.page.core.0": "$(thing)CAD$(0)의 $(thing)코어$(0)는 기본적으로 CPU입니다--$(l:components/socket)$(thing)소켓$(0)$(/l)의 $(thing)주문$(0)을 읽고, 계산을 실행하고, $(thing)프사이 에너지$(0)를 사용하여 $(thing)동작$(0)의 효과를 만들어 내는 역할을 합니다.$(p)$(thing)CAD 코어$(0)는 중앙 먼지 주위에 배치된 4개의 $(thing)프사이$(0) 전도성 물질로 제작됩니다(프로세서).",
  "psi.book.page.core.1": "모든 $(thing)CAD 코어$(0)에는 $(thing)코어$(0)가 $(thing)주문$(0)당 수행할 수 있는 최대 연산 수($(thing)선택$(0), $(thing)연산자$(0), 비디버그 $(thing)동작$(0))인 $(l:basics/tutorial_5#complexity)$(thing)복잡성$(0)$(/l)이 있습니다.$(p)$(thing)코어$(0)에는 한 번에 수행할 수 있는 총 비디버그 $(thing)동작$(0)수인 $(l:basics/tutorial_5#projection)$(thing)투영$(0)$(/l)도 있습니다.",
  "psi.book.page.core.2": "$(l:components/psidust)$(item)프사이 가루$(0)$(/l)조각 주위에 $(item)철$(0)로 만든 $(item)기본 CAD 코어$(0)는 종종 최초의t $(thing)CAD 코어$(0) 마법사 제작품입니다.$(p)환상적이지는 않지만(특히 한 번에 하나의 $(thing)동작$(0)만 시전할 수 있음), 초보자의 필요를 충족시키기에 충분합니다.",
  "psi.book.page.core.3": "주문을 말해 보십시오.",
  "psi.book.page.core.4": "$(l:components/psimetal)$(item)프사이 금속$(0)$(/l)을 $(thing)CAD 코어$(0) 주위에 $(item)철$(0)로 대체하면 $(thing)코어$(0)의 중앙에 다른 먼지 성분을 사용할 수 있습니다.$(p)$(item)레드스톤 가루$(0)를 먼지에 사용하면 $(item)오버클럭된 CAD 코어$(0)를 얻을 수 있습니다. 오버클럭된 CAD 코어는 $(l:components/core#basic)$(item)기본$(0)$(/l) CAD 코어에 비해 두 배의 $(l:basics/tutorial_5#complexity)$(thing)복잡성$(0)$(/l)을 자랑하며 $(l:basics/tutorial_5#projection)$(thing)투영$(0)$(/l)을 세 번 반복합니다.",
  "psi.book.page.core.5": "햇 트릭입니다.",
  "psi.book.page.core.6": "대신 $(l:components/psimetal)$(item)프사이 금속$(0)$(/l) 쉘에 $(item)발광석 가루$(0)조각을 넣으면 $(item)전도성 CAD 코어$(0)를 만들 수 있습니다.$(p)이 $(thing)코어$(0)는 $(item)레드스톤 가루$(0)기반 코어보다 덜 $(l:basics/tutorial_5#complexity)$(thing)복잡$(0)$(/l)하지만 $(l:components/core#overclocked)$(item)오버클럭된 CAD 코어$(0)$(/l)의 3가지 동작보다 4가지 $(thing)동작$(0)을 한 번에 처리할 수 있습니다.",
  "psi.book.page.core.7": "정말 까다로운 일이네요.",
  "psi.book.page.core.8": "$(thing)CAD 코어$(0)의 제작법에 두 개의 $(l:components/psigem)$(item)프사이 보석$(0)$(/l)을 포함하면 $(o)상당한$() 성능 이점을 얻을 수 있습니다.$(p)$(item)레드스톤 가루$(0)가 중앙에 있는 $(item)하이퍼클럭된 CAD 코어$(0)는 $(l:components/core#conductive)$(item)전도성$(0)$(/l) 코어의 $(l:basics/tutorial_5#complexity)$(thing)복잡성$(0)$(/l)$(o)과$() $(l:components/core#overclocked)$(item)오버클럭된 CAD 코어$(0)$(/l)의 $(l:basics/tutorial_5#projection)$(thing)투영$(0)$(/l)을 두 배로 높입니다.",
  "psi.book.page.core.9": "시간은 말하지 않겠습니다만",
  "psi.book.page.core.10": "$(item)발광석 가루$(0)가 중앙에 있는 $(thing)CAD 코어$(0)에서 $(l:components/psigem)$(item)프사이 보석$(0)$(/l)을 사용하면 $(item)발광하는 CAD 코어$(0)를 얻을 수 있습니다.$(p)이 $(thing)코어$(0)는 $(l:components/core#hyperclocked)$(item)하이퍼클럭된 CAD 코어$(0)$(/l)에 비해 $(l:basics/tutorial_5#projection)$(thing)투영$(0)$(/l)이 적지만, $(o)7가지$() $(thing)동작$(0)을 시전할 수 있습니다.",
  "psi.book.page.core.11": "테크네튬이 포함되지 않았습니다.",
  "psi.book.entry.socket": "소켓",
  "psi.book.page.socket.0": "$(thing)CAD$(0) $(thing)소켓$(0)은 기본적으로 탄환 클립입니다.$(p)그것은 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)에 로드되는 것이고, 처리를 위해 $(l:items/spell_bullet)$(thing)탄환$(0)$(/l)에 포함된 컴파일된 $(thing)주문$(0)을 $(l:components/core)$(thing)코어$(0)$(/l)로 전송하는 역할을 합니다.$(p)$(thing)소켓$(0)은 금속 기판에서 $(l:items/spell_bullet)$(thing)탄환$(0)$(/l)과 인터페이스하는 먼지 조각으로 제작됩니다.",
  "psi.book.page.socket.1": "$(thing)소켓$(0)에는 한 번에 $(l:components/core)$(thing)코어$(0)$(/l)로 전송할 수 있는 $(thing)주문$(0)의 최대 크기(그리드 공간)인 $(l:basics/tutorial_5#bandwidth)$(thing)대역폭$(0)$(/l)이 있습니다-- 예를 들어 대역폭이 5인 $(thing)소켓$(0)은 최대 5x5까지 $(thing)주문$(0)을 전송할 수 있습니다.$(p)또한 $(thing)소켓$(0)도 여러 개 있습니다. 이 소켓은 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)을 각각 하나씩 넣을 수 있는 구획입니다.",
  "psi.book.page.socket.2": "$(item)기본 CAD 소켓$(0)은 $(item)철$(0) 기판에서 $(l:components/psidust)$(item)프사이 가루$(0)$(/l)로 제작된 $(thing)소켓$(0) 중 가장 단순합니다.$(p)한 번에 최대 4개의 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)을 저장할 수 있으며 최대 5x5 크기의 $(thing)주문$(0)을 전송할 수 있습니다.",
  "psi.book.page.socket.3": "플러그와 통통",
  "psi.book.page.socket.4": "$(thing)소켓$(0)의 $(item)철$(0) 기판을 $(thing)프사이 에너지$(0) (즉, $(l:components/psimetal)$(item)프사이 금속$(0)$(/l))에 더 전도성이 높은 금속으로 교체하면 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)과 연결할 다른 가루를 선택할 수 있습니다.$(p)$(item)레드스톤 가루$(0)를 사용하면 최대 6개의 $(l:items/spell_bullet)$(thing)탄환$(0)$(/l)을 저장할 수 있는 $(item)신호 CAD 소켓$(0)을 얻을 수 있으며, $(thing)주문$(0)이 들어갈 각 소켓의 크기는 최대 7x7입니다.",
  "psi.book.page.socket.5": "러시안 룰렛에 완벽함",
  "psi.book.page.socket.6": "$(l:components/psimetal)$(item)프사이 금속$(0)$(/l) 기판에 $(item)발광석 가루$(0)를 놓으면 $(item)대형 CAD 소켓$(0)이 만들어집니다.$(p)이 $(thing)소켓$(0)은 $(l:components/socket#signaling)$(item)신호$(0)$(/l) 소켓만큼 큰 $(thing)주문$(0)을 처리할 수 없으며 최대 6x6 크기까지만 관리할 수 있지만 한 번에 최대 8개의 $(l:items/spell_bullet)$(thing)탄환$(0)$(/l)을 저장할 수 있습니다.",
  "psi.book.page.socket.7": "사실상 끝이 없다.",
  "psi.book.page.socket.8": "$(l:components/psigem)$(item)프사이 보석$(0)$(/l)으로 $(thing)소켓$(0)을 보강하면 훨씬 더 많은 데이터를 훨씬 더 빠르게 전송할 수 있습니다.$(p)이와 같이 늘어난 $(l:components/socket#signaling)$(item)신호 CAD 소켓$(0)$(/l)은 최대 10개의 $(l:items/spell_bullet)$(thing)탄환$(0)$(/l)을 저장할 수 있는 $(item)전달 가능한 CAD 소켓$(0)이 되며 $(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)에 $(o)맞는$() $(thing)주문$(0)을 모두 처리할 수 있습니다.",
  "psi.book.page.socket.9": "아바리티아의 베인",
  "psi.book.page.socket.10": "$(l:components/psigem)$(item)프사이 보석$(0)$(/l)으로 보강된 $(l:components/socket#large)$(item)대형 CAD 소켓$(0)$(/l)은 상상력적으로 이름 붙여진 $(item)초대형 CAD 소켓$(0)이 됩니다.$(p)이 중 하나는 $(l:components/socket#transmissive)$(item)전달 가능한 소켓$(0)$(/l)의 $(l:basics/tutorial_5#bandwidth)$(thing)대역폭$(0)$(/l)이 없지만(8x8 이하의 $(thing)주문$(0)만 가능) 최대 12개의 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)을 저장할 수 있습니다.",
  "psi.book.page.socket.11": "옵히우쿠스가 개의치 않길 바란다.",
  "psi.book.entry.battery": "배터리",
  "psi.book.page.battery.0": "$(thing)CAD 배터리$(0)는 사용자의 $(thing)프사이 에너지$(0)를 무기한 저장할 수 있는 $(thing)CAD$(0)에 대한 옵션 부착물이며, $(thing)오버플로우$(0)는 양을 나타냅니다.$(p)$(thing)배터리$(0)는 사용자가 $(thing)프사이 에너지$(0)를 모두 공급한 후 $(thing)CAD$(0)가 사용자의 상태에 도달하기 전에 방전됩니다.",
  "psi.book.page.battery.1": "사실상 $(thing)배터리$(0)는 저장된 $(thing)프사이 에너지$(0)의 작은 안전망을 의미합니다.$(p)그것은 여러분이 $(o)손상$()을 입거나 $(thing)프사이 에너지$(0)가 다시 충전되기를 기다릴 필요 없이 조금 과도하게 그릴 수 있게 해줍니다.$(p)모든 $(thing)배터리$(0)는 $(item)철 주괴$(0)와 $(item)금 주괴$(0) 사이에 둘러싸인 $(thing)프사이 에너지$(0) 전도성 물질로 제작됩니다.$(p)$(piece)선택: 시전자 배터리$(0)를 사용한 $(thing)주문$(0)에서 $(thing)배터리$(0)의 현재 충전량에 접근할 수 있습니다.",
  "psi.book.page.battery.2": "리튬 이온이 아닙니다.",
  "psi.book.page.battery.3": "예쁜 금속입니다.",
  "psi.book.page.battery.4": "1-(800)-BATTERY로 전화하십시오.",
  "psi.book.entry.colorizer": "염색체",
  "psi.book.page.colorizer.0": "$(thing)CAD 염색체$(0)는 사용자의 $(thing)프사이 에너지$(0)가 물리적 세계에서 나타날 때 색상을 수정하는 $(thing)CAD$(0)에 선택적으로 부착되는 기능입니다.$(p)모든 $(thing)염색체$(0)는 $(item)철 주괴$(0)의 기반, 위에 $(l:components/psidust)$(item)프사이 가루$(0)$(/l) 조각, $(item)유리$(0) 두 조각(양쪽에 하나씩), 그리고 중앙에 적용할 색상 아이템을 사용하여 제작됩니다. ",
  "psi.book.page.colorizer.1": "$(thing)염색체$(0)는 16가지 바닐라 $(item)염료$(0)중 하나와 함께 각각의 색상에 맞게 제작할 수 있습니다.$(p)염료 대신 $(item)프리즈머린 수정$(0)을 사용하면 결과물인 $(thing)염색체$(0)가 무지개의 색을 따라 이동합니다.$(p)반면에 색상 아이템을 사용하지 $(o)않을$() 경우, 결과 $(thing)염색체$(0)는 사용자의 $(thing)프사이 에너지$(0)에서 색상을 $(o)추출$()하고 결과 입자는 $(o)거의$() 보이지 않게 됩니다.",
  "psi.book.page.colorizer.2": "$(l:components/psidust)$(item)프사이 가루$(0)$(/l) 조각을 $(thing)염색체$(0)의 색상 항목으로 사용하는 것은 대부분의 사람들에게 알려진 효과가 없는 것처럼 보이지만, 일부 개인은 다르게 보고했습니다.$(p)$(thing)CAD$(0)의 $(thing)염색체$(0)는 $(p)$(li)$(thing)CAD$(0)에서 방출되는 입자;$(p)$(li)발사체 및 $(l:items/circle_bullet)$(thing)주문 원$(0)$(/l) 시전;$(p)$(li)$(piece)소환 동작$(0)에 의해 마법에 걸린 블록 및 조명에 영향을 미칩니다.",
  "psi.book.page.colorizer.3": "무지개를 맛보십시오",
  "psi.book.category.items": "아이템",
  "psi.book.category.items.desc": "이 섹션에는 $(thing)주문$(0) 작성 환경을 향상시키는 데 사용할 수 있는 모든 아이템, 도구 및 유틸리티가 가득합니다.",
  "psi.book.entry.spellBullet": "주문 탄환 종류",
  "psi.book.page.spellBullet.0": "$(thing)주문 탄환$(0)은 $(thing)CAD$(0)의 $(l:components/socket)$(thing)소켓$(0)$(/l)에 삽입하면 포함된 $(thing)주문$(0)의 데이터(및 메타데이터)를 $(thing)CAD$(0)에 제공하는 간단한 장치입니다.$(p)하지만 $(thing)탄환$(0)은 여러 종류가 있는데, 각각의 장점이 있습니다.$(p)다음 페이지에 연결된 각 항목에는 해당 유형의 $(thing)탄환$(0)에 대한 자세한 정보가 있습니다.",
  "psi.book.page.spellBullet.1": "특정 유형의 $(thing)주문 탄환$(0)을 원하는 경우 여기 있습니다.",
  "psi.book.page.spellBullet.2": "모든 유형의 $(thing)주문 탄환$(0)은 $(item)철 주괴$(0)와 $(l:components/psidust)$(item)프사이 가루$(0)$(/l) 조각으로 제작 그리드에 수평으로 배치되어 있습니다.$(p)다른 어떤 것도 제작법에 추가되지 않으면 가장 기본적인 유형의 $(thing)주문 탄환$(0)이 생성됩니다. (어쩐지 헷갈리네요) 그냥 $(l:items/basic_bullet)$(item)주문 탄환$(0)$(/l)이라고 불렀죠.$(p)다른 유형의 $(thing)주문 탄환$(0)에는 $(item)철 주괴$(0)와 수평으로 인접한 한 가지 성분이 더 필요합니다.",
  "psi.book.page.spellBullet.3": "다른 종류의 $(thing)주문 탄환$(0)의 재료는 다음과 같습니다:$(p)$(li) $(l:items/projectile_bullet)$(item)발사체형 주문 탄환$(0)$(/l)에는 $(item)화살$(0),$(p)$(li) $(l:items/loopcast_bullet)$(item)반복형 주문 탄환$(0)$(/l)에는 $(item)실$(0),$(p)$(li) $(l:items/circle_bullet)$(item)주문 원 탄환$(0)$(/l)에는 원형 아이템($(item)눈덩이$(0) 또는 $(item)슬라임볼$(0)),$(p)$(li) $(l:items/grenade_bullet)$(item)수류탄형 주문 탄환$(0)$(/l)에는 $(item)화약$(0),$(p)$(li) $(l:items/charge_bullet)$(item)충전형 주문 탄환$(0)$(/l)에는 $(item)레드스톤 가루$(0), 그리고$(p)$(li) $(l:items/mine_bullet)$(item)지뢰형 주문 탄환$(0)$(/l)에는 $(item)버튼$(0)이 필요합니다.",
  "psi.book.page.spellBullet.4": "$(thing)주문 탄환$(0)을 $(thing)CAD$(0)에 로드하려면 먼저 $(thing)주문$(0)이 저장되어 있어야 합니다.$(p)$(thing)탄환$(0) 안에 $(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)의 $(thing)주문$(0)을 저장하려면 $(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l) 위에 $(thing)주문 탄환$(0)을 문지르면 됩니다($(k:use)).$(p)$(thing)주문 탄환$(0)에 저장된 $(thing)주문$(0은 저장 목적으로 그리드의 빈 $(l:items/spell_drive)$(item)주문 드라이브$(0)$(/l)에 복사할 수 있습니다..",
  "psi.book.page.spellBullet.5": "$(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l) 컴파일하는 $(thing)주문$(0)에 대한 $(l:basics/tutorial_5#cost)$(thing)비용$(0)$(/l)을 표시하지만 $(thing)탄환$(0) 유형에 따라 이 $(l:basics/tutorial_5#cost)$(thing)비용$(0)$(/l)은 다를 수 있습니다.$(p)$(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l)의 값은 $(l:items/basic_bullet)$(item)주문 탄환$(0)$(/l)이라고 하는 가장 기본적인 유형의 $(thing)주문 탄환$(0)으로 보정됩니다.",
  "psi.book.page.spellBullet.6": "다른 모든 유형의 $(thing)주문 탄환$(0)에는 $(thing)비용 곱셈기$(0)가 백분율로 표시됩니다. 이 곱셈은 해당 $(thing)탄환$(0) 유형에 대한 $(thing)주문$(0)의 실제 $(l:basics/tutorial_5#cost)$(thing)비용$(0)$(/l)을 결정하기 위해 $(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l)에 표시된 비용에 곱할 수 있습니다.$(p)예를 들어, $(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l)에서 $(thing)주문$(0)에 300의 최종 비용이 표시되는 경우, $(l:items/projectile_bullet)$(item)발사체형 주문 탄환$(0)$(/l)(102%%의 $(thing)비용 곱셈기$(0))에 복사하면 시전할 때마다 실제 $(l:basics/tutorial_5#cost)$(thing)비용$(0)$(/l)은 $(br)300 \u00d7 102%% = 306 $(thing)프사이 에너지$(0)입니다.",
  "psi.book.page.spellBullet.7": "$(thing)주문 탄환$(0)의 많은 유형은 $(thing)주문$(0)이 시전된 시점과 실제로 실행되는 시점 사이의 지연을 초래합니다.$(p)따라서 $(thing)주문$(0) 시 발생하는 $(l:basics/tutorial_5#cost)$(thing)비용$(0)$(/l)은 전액 선불로 지불되며, $(thing)주문$(0) 시 $(thing)동작$(0)이 실제로 시전되지 않더라도 환불되지 않습니다.",
  "psi.book.page.spellBullet.8": "모든 $(thing)주문$(0)에는 시전 시 $(thing)초점$(0)이 있습니다.$(p)$(thing)초점$(0)은 시전의 $(thing)프사이 에너지$(0)가 세상에 투영되는 지점입니다(하나 이상의 $(thing)동작$(0)).$(p)물론, a $(thing)초점$(0)은 32블록 이상 떨어진 곳(시전자에 영향을 미치는 블록 제외)에서 $(thing)동작$(0)을 실행하거나 $(thing)선택$(0)을 평가할 수 없습니다.$(p)$(thing)주문$(0)은 $(piece)선택: 초점$(0)을 사용하여 $(thing)초점$(0)에 접근할 수 있습니다.",
  "psi.book.page.spellBullet.9": "$(thing)초점$(0)의 위치는 초점이 시전된 $(thing)주문 탄환$(0)의 유형에 따라 달라집니다.$(p)기본 $(l:items/basic_bullet)$(item)주문 탄환$(0)$(/l)의 $(thing)초점$(0)은 단순히 $(thing)주문$(0)의 시전자이지만 다른 유형의 $(l:items/basic_bullet)$(item)주문 탄환$(0)$(/l)은 다른 $(thing)초점$(0)을 만들 수 있습니다.$(p)예를 들어, $(l:items/projectile_bullet)$(item)발사체형 주문 탄환$(0)$(/l)의 $(thing)초점$(0)은 발사체 자체입니다.$(p)각 $(thing)탄환$(0) 유형의 $(thing)초점$(0) 및 기호에 대한 자세한 내용은 개별 항목을 참조하십시오.",
  "psi.book.entry.basicBullet": "주문 탄환",
  "psi.book.page.basicBullet.0": "가장 간단한 유형의 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)(및 아이템 줄의 이름), 인 보잘것없는 $(item)주문 탄환$(0)에는 $(thing)주문$(0)이 저장됩니다.$(p)저장된 $(thing)주문$(0)이 시전되면 즉시 실행됩니다. 이러한 유형의 $(l:items/spell_bullet)$(thing)탄환$(0)$(/l)의 $(l:items/spell_bullet#focal_point)$(thing)초점$(0)$(/l)은 시전자일 뿐입니다. 그것의 시전 비용은 정확히 $(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)가 말하는 것과 같습니다.$(p)웃을 일이 아니에요.",
  "psi.book.page.basicBullet.1": "화약은 필요 없습니다.",
  "psi.book.entry.projectileBullet": "발사체형 주문 탄환",
  "psi.book.page.projectileBullet.0": "$(item)발사체형 주문 탄환$(0)에서 시전된 $(thing)주문$(0)이 즉시 실행되지 않습니다.$(p)대신 빠르게 움직이는 $(thing)주문 발사체$(0)가 시전된 $(thing)CAD$(0) 끝에서 발사됩니다.$(p)이 발사체는 $(thing)주문$(0)의 $(l:items/spell_bullet#focal_point)$(thing)초점$(0)$(/l) 역할을 하여 발사체가 무언가와 충돌할 때 실행합니다.",
  "psi.book.page.projectileBullet.1": "그다지 높지 않아요.",
  "psi.book.page.projectileBullet.2": "$(thing)주문 발사체$(0)는 물리적인 것이 아니라 포함된 $(thing)주문$(0) 주위에서 $(thing)프사이 에너지$(0)의 얇은 래퍼입니다(따라서 $(l:items/spell_bullet)$(thing)탄환$(0)$(/l)의 추가 비용이 발생합니다.).$(p)따라서 소멸되기 전에 최대 30초 동안 지속될 수 있습니다.$(p)$(thing)주문 발사체$(0)는 매우 빠르게 움직이며 수명 동안 도움 없이 200블록 이상의 거리를 이동할 수 있습니다.",
  "psi.book.page.projectileBullet.3": "발사체가 블록 또는 엔티티와 충돌할 경우 저장된 $(thing)주문$(0)이 활성화됩니다.$(p)후자의 경우 $(piece)선택: 대상 공격$(0)을 사용하여 적중된 엔티티를 식별할 수 있습니다.$(p)반면에, 발사체가 그 시간 동안 아무 것도 맞추지 $(o)못하면$(), $(thing)주문$(0)은 흐지부지되어 $(thing)프사이 에너지$(0)가 낭비될 것입니다-- 그러니 조심해서 겨냥하십시오!",
  "psi.book.entry.loopcastBullet": "반복형 주문 탄환",
  "psi.book.page.loopcastBullet.0": "$(item)반복형 주문 탄환$(0)에서 시전된 $(thing)주문$(0)이 일반 $(l:items/basic_bullet)$(item)주문 탄환$(0)$(/l)에서처럼 실행됩니다.$(p)반복해서요.$(p)이러한 $(l:items/spell_bullet)$(thing)탄환들$(0)$(/l) 중 하나에서 시전된 $(thing)주문$(0)은 시전된 $(thing)CAD$(0)가 같은 손에 잡히지 않거나 다른 $(thing)주문$(0)을 선택할 때까지 초당 4회 쉬지 않고 계속 실행됩니다.",
  "psi.book.page.loopcastBullet.1": "광기의 정의",
  "psi.book.page.loopcastBullet.2": "$(item)반복형 주문 탄환$(0)에서 시전된 $(thing)주문$(0)의 $(l:items/spell_bullet#focal_point)$(thing)초점$(0)$(/l)은 시전자일 뿐이며, 실행 시마다 전체 $(thing)프사이 에너지$(0) 비용이 발생합니다.$(p)$(l:items/spell_bullet)$(thing)탄환$(0)$(/l) 중 하나를 사용하여 반복적으로 빠르게 시전할 수 있는 가장 큰 장점은 $(thing)프사이 에너지$(0)를 $(o)재생$()하는 것입니다.",
  "psi.book.page.loopcastBullet.3": "여러분이 $(thing)주문$(0)을 시전하거나 손상을 입었을 때, $(thing)프사이 에너지$(0)는 순간적으로 불안정하게 남습니다; 그것은 여러분이 내면에 집중하고 회복할 수 있을 때까지 재생될 수 없습니다.$(br)이러한 복원 작업은 어렵지 않지만 시간이 조금 걸립니다.$(p)하지만 $(item)반복형 주문 탄환$(0)에서 던지면, 이 지연은 $(o)초기$()에만 발생합니다-- 그 후에 $(l:items/spell_bullet)$(thing)탄환$(0)$(/l)은 $(thing)프사이 에너지$(0)를 방해하지 않고 정상적으로 재생됩니다.",
  "psi.book.page.loopcastBullet.4": "이러한 $(l:items/spell_bullet)$(thing)탄환들$(0)$(/l) 중 하나에서 시전된 $(thing)주문$(0)은 호출할 때마다 다른 작업을 수행할 수 있습니다.$(p)특히 $(piece)선택: 반복 시전 횟수$(0)는 $(thing)주문$(0)을 처음 시전한 후 주문이 실행된 횟수를 반환합니다.$(p)따라서 $(thing)주문$(0)이 처음 실행될 때 1을 반환하고, 두 번째로 2를 반환하는 식으로 작동합니다.",
  "psi.book.page.loopcastBullet.5": "이러한 $(l:items/spell_bullet)$(thing)탄환들$(0)$(/l)은 $(piece)연산자: 나눗셈$(0) 및 $(piece)연산자: 나머지$(0)와 함께 사용하면 $(o)넓은 영역$()에서 손쉽게 대량으로 작업을 수행할 수 있습니다.",
  "psi.book.entry.circleBullet": "주문 원 탄환",
  "psi.book.page.circleBullet.0": "$(item)주문 원 탄환$(0)에서 시전된 $(thing)주문$(0)은 연속해서 정확히 20번 실행됩니다.$(p)$(thing)주문$(0)이 처음 시전되면 시전자가 보고 있는 지점에 $(thing)주문 원$(0)이 시전자로 표시되어 $(thing)주문$(0)의 $(l:items/spell_bullet#focal_point)$(thing)초점$(0)$(/l) 역할을 합니다. 이 원은 5초 후에 $(thing)프사이 에너지$(0)가 고갈될 때까지 1초에 4번씩 $(thing)주문$(0)을 실행합니다.",
  "psi.book.page.circleBullet.1": "주문계의 코스트코",
  "psi.book.page.circleBullet.2": "$(thing)주문 원$(0)은 처음 시전할 때 시전자 위치에서 최대 32블록 떨어진 곳 또는 시전자에서 가장 가까운 블록(더 가까운 블록)에 시전자로 표시됩니다.$(p)$(l:items/loopcast_bullet)$(item)반복형 주문 탄환$(0)$(/l)과 마찬가지로 $(thing)주문 원$(0)에서 시전된 $(thing)주문$(0)은 $(piece)선택: 반복 시전 횟수$(0)를 사용하여 반복된 내용을 알 수 있습니다(1에서 20까지의 숫자 포함).",
  "psi.book.page.circleBullet.3": "$(thing)주문 원$(0)은 처음 시전할 때 필요한 $(thing)프사이 에너지$(0)를 모두 소모하므로 $(thing)비용 승수$(0)가 1500%%에 달합니다.$(p)그러나 이 회사의 엄청난 $(l:basics/tutorial_5#cost)$(thing)비용$(0)$(/l)은 혜택이 없는 것은 아닙니다; 소형 자체 포함 설계로 $(o)매우$() 효율적이기 때문에 15개의 비용으로 $(thing)주문$(0)을 20번 실행할 수 있습니다.$(p)추적 중인 고객에게는 실행당 25%%의 할인 혜택이 적용됩니다.",
  "psi.book.page.circleBullet.4": "$(item)주문 원 탄환$(0)은 다양하고 $(thing)프사이 에너지$(0)를 보존하기 때문에 새롭고 경험이 많은 주문자들 사이에서 인기가 있습니다.$(p)이와 같이, 다른 곳에서는 볼 수 없는 $(item)주문 원 탄환$(0)과 함께 사용되는 비교적 일반적인 $(thing)동작$(0)이 몇 가지 있습니다.",
  "psi.book.page.circleBullet.5": "비교적 간단하게 만들 수 있는 $(thing)서클싱크$(0) 관용구는 $(thing)주문$(0)의 20개의 실행이 동시에 일어나도록 하여, 단일 실행보다 훨씬 더 큰 효과로 축적될 수 있게 합니다.$(p)$(thing)20비트 타워$(0) 관용구는 $(l:items/vector_ruler)$(item)벡터 자$(0)$(/l)를 포함하는 조금 더 어려운 설정을 가지고 있지만 $(thing)주문$(0)은 20개의 실행 중 일부에만 무언가를 할 수 있습니다.",
  "psi.book.subsec.circleBullet.6": "서클싱크",
  "psi.book.page.circleBullet.6": "$(thing)서클싱크$(0) 관용구(오른쪽 사진)는 핵심에 $(piece)동작: 미루기$(0)를 사용합니다.$(p)$(thing)주문$(0)에 들어가면 최종 $(thing)동작$(0)이 활성화될 때까지 남은 시간에 정확히 맞춰 각 실행을 지연시킵니다.$(p)$(piece)동작: 미루기$(0) 뒤에 배치된 모든 $(thing)동작$(0)이 동시에 실행됩니다.",
  "psi.book.page.circleBullet.7": "별들이 정렬되면...",
  "psi.book.subsec.circleBullet.8": "20비트 타워",
  "psi.book.page.circleBullet.8": "$(thing)20비트 타워$(0) 관용구는 다소 진보된 기술이고, 다소 기술적인 디자인입니다.$(p)이 도구를 사용하려면 $(l:items/vector_ruler)$(item)벡터 자$(0)$(/l)가 있는 블록을 선택한 다음 선택한 위치 바로 위의 20개 블록 높이의 수직 공간에 일부 블록(상관 없음)을 배치한 다음 다음 페이지의 코드를 $(thing)주문$(0) 맨 위에 복사합니다.",
  "psi.book.page.circleBullet.9": "수직 공간의 각 블록 위치는 $(thing)주문$(0)의 한 실행을 나타냅니다; 타워의 맨 아래 위치는 첫 번째 실행, 다음 위치는 두 번째 실행 등을 나타냅니다.$(p)타워의 빈 공간은 \"이 반복 시 $(o)실행$()\"을 나타냅니다. 그리고 그 위치에 있는 블록은 $(thing)주문$(0) \"$(o)불가$()\"를 나타냅니다.$(p)마지막으로, 다음 페이지의 코드를 $(thing)주문$(0) 맨 위에 복사합니다.",
  "psi.book.page.circleBullet.10": "조건부로",
  "psi.book.entry.grenadeBullet": "수류탄형 주문 탄환",
  "psi.book.page.grenadeBullet.0": "$(item)수류탄형 주문 탄환$(0)에서 시전된 $(thing)주문$(0)은 즉시 실행하는 대신 $(thing)주문 수류탄$(0)에서 시전된 $(thing)CAD$(0)의 끝부분에서 발사됩니다.$(p)하지만 $(l:items/projectile_bullet)$(thing)주문 발사체$(0)$(/l)와 달리 수류탄$(o)은$() 중력의 영향을 받습니다.$(p)포함된 $(thing)주문$(0)은 빠르면 빠르면 빠를수록 정확히 3초 후에 실행합니다.",
  "psi.book.page.grenadeBullet.1": "핀이 아니라 트리거를 당깁니다.",
  "psi.book.page.grenadeBullet.2": "$(thing)주문 수류탄$(0)은 $(item)수류탄형 주문 탄환$(0)에 의해 초과된 에너지로 만들어진 $(thing)프사이 에너지$(0)의 무형 얇은 래퍼입니다.$(p)마법의 수류탄은 실행될 때 $(thing)주문$(0)의 $(l:items/spell_bullet#focal_point)$(thing)초점$(0)$(/l) 역할을 하기도 합니다.$(p)처음에는 사용이 제한된 것처럼 보이지만, $(thing)주문 수류탄$(0)은 $(l:items/projectile_bullet)$(thing)주문 발사체$(0)$(/l)가 사용할 수 없는 위치(예: 벽이나 구멍 안쪽)에 도달할 수 있습니다.",
  "psi.book.page.grenadeBullet.3": "$(thing)주문 수류탄$(0)은 마지막으로 접촉한 엔티티를 기록합니다.$(p)포함된 $(thing)주문$(0)이 실행될 때 해당될 경우 $(piece)선택: 대상 공격$(0)에서 이 엔티티에 접근할 수 있습니다.",
  "psi.book.entry.chargeBullet": "충전형 주문 탄환",
  "psi.book.page.chargeBullet.0": "$(item)충전형 주문 탄환$(0)에서 시전된 $(thing)주문$(0)은 즉시 실행하는 대신 $(thing)주문 충전$(0)에서 시전된 $(thing)CAD$(0)의 끝부분에서 발사됩니다. 이 주문 탄환에서 시전된 주문 탄환은 마치 $(l:items/grenade_bullet)$(thing)주문 수류탄$(0)$(/l)인 것처럼 중력에 복종합니다.$(p)그러나 $(l:items/grenade_bullet)$(thing)주문 수류탄$(0)$(/l)과는 달리 $(thing)주문 충전$(0)은 최대 5분 동안 지속될 수 있으며 $(l:items/detonator)$(item)주문 뇌관$(0)$(/l)이 특별히 지시할 때만 $(thing)주문$(0)을 실행합니다.",
  "psi.book.page.chargeBullet.1": "쌓입니다.",
  "psi.book.page.chargeBullet.2": "$(thing)주문 충전$(0)은 포함된 $(thing)주문$(0) 주위에 있는 $(thing)프사이 에너지$(0)의 안정적인 쉘로 실행 시 $(thing)주문$(0)의 $(l:items/spell_bullet#focal_point)$(thing)초점$(0)$(/l) 역할을 합니다.$(p)$(thing)주문 충전$(0)이 수명 내에 활성화되지 않으면 단순히 소멸되어 내부에서 $(thing)주문$(0)이 흐지부지되고 투자된 $(thing)프사이 에너지$(0)가 낭비됩니다.",
  "psi.book.page.chargeBullet.3": "그러나 근접한 많은 $(thing)주문 충전$(0)은 단일 $(l:items/detonator)$(item)주문 뇌관$(0)$(/l)(또는 $(piece)동작: 폭파$(0))에 의해 모두 한 번에 활성화될 수 있으므로 대량 효과에 매우 유용합니다.$(p)$(thing)주문 충전$(0)은 부딪치는 마지막 엔티티(또는 마지막으로 엔티티를 밟는 경우)를 기록합니다.$(p)포함된 $(thing)주문$(0)이 실행될 때 해당될 경우 $(piece)선택: 대상 공격$(0)에서 이 엔티티에 접근할 수 있습니다.",
  "psi.book.entry.mineBullet": "지뢰형 주문 탄환",
  "psi.book.page.mineBullet.0": "$(item)지뢰형 주문 탄환$(0)에서 시전된 $(thing)주문$(0)은 $(thing)주문 지뢰$(0)에서 시전된 $(thing)CAD$(0)에서 발사됩니다.$(p)$(thing)주문 지뢰$(0)는 중력에 복종하고 5분의 수명을 가지고 있으며 저장된 $(thing)주문$(0)을 누군가(또는 무엇인가가) 밟은 후에만 실행합니다.",
  "psi.book.page.mineBullet.1": "시골길...",
  "psi.book.page.mineBullet.2": "$(thing)주문 지뢰$(0)의 실행 조건은 매우 까다롭습니다; 지뢰는 땅에 남아 밟히기를 기다리는 것으로 시작합니다.$(p)한 개 또는 그 이상의 엔티티가 밟을 때, 지뢰는 바로 발동되지 않고, 대신 스스로 소결됩니다.$(p)준비가 완료되고 더 이상 맨 위에 엔티티가 없을 때에만 포함된 $(thing)주문$(0)을 실행합니다.",
  "psi.book.page.mineBullet.3": "$(piece)선택: 대상 공격$(0)에서 $(thing)주문$(0)을 트리거한 엔티티(즉, $(thing)주문 지뢰$(0)에 마지막으로 발을 뗀 엔티티)에 접근할 수 있습니다.$(p)하지만, 만약 $(thing)주문 지뢰$(0)의 활성화 조건이 일생 동안 충족되지 않는다면, 지뢰는 저장된 에너지를 흐릿하게 하면서 간단히 사라질 것입니다.$(p)따라서 $(thing)주문 지뢰$(0)에 착륙할 경우 시전자가 무엇을 준비하고 있는지 아는 것보다 기다리는 것이 더 나을 수 있습니다.",
  "psi.book.entry.detonator": "주문 뇌관",
  "psi.book.page.detonator.0": "$(item)주문 뇌관$(0)은 $(item)철 주괴$(0) 2개, $(l:components/psidust)$(item)프사이 가루$(0)$(/l)와 $(item)버튼$(0)으로 제작됩니다.$(p)이것은 정확히 한 가지 기능을 합니다: 작동되면($(k:use)) 32블록 반경에서 사용자가 던지는 모든 $(l:items/charge_bullet)$(thing)주문 충전$(0)$(/l)(및 $(l:items/exosuit_sensor#trigger)$(item)엑소수트 뇌관 센서$(0)$(/l))를 활성화하여 포함된 $(thing)주문$(0)을 동시에 실행하도록 지시합니다.",
  "psi.book.page.detonator.1": "첫번째 폭탄",
  "psi.book.entry.exosuit": "프사이 금속 엑소수트",
  "psi.book.page.exosuit.0": "$(thing)프사이 금속 엑소수트$(0)는 일상적인 모험에 $(thing)주문$(0) 시전을 완벽하게 접목시킬 수 있는 갑옷입니다!$(p)$(thing)엑소수트$(0)의 각 조각은 $(l:components/psigem)$(item)프사이 보석$(0)$(/l) 2개와 일부 $(l:components/psimetal)$(item)프사이 금속$(0)$(/l)으로 제작되었으며 각각의 트리거가 활성화될 때 $(thing)주문$(0)을 만들 수 있습니다.",
  "psi.book.page.exosuit.1": "이 수트의 $(thing)주문$(0)은 $(thing)CAD$(0)와 함께 포커스로 시전되므로 일반적인 $(thing)CAD$(0) 한계가 적용됩니다.$(p)$(thing)프사이 금속 엑소수트$(0)의 각 조각은 $(l:basics/cad_assembler)$(item)CAD 조립기$(0)$(/l)에 최대 3개의 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)을 장착할 수 있지만, 안타깝게도 일부 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l) 변형은 이 수트와 잘 어울리지 않습니다.$(p)수트 조각은 $(thing)주문$(0)을 성공적으로 건넨 횟수를 기억합니다; 이 횟수는 $(piece)선택: 성공 카운터$(0)에서 접근할 수 있습니다.",
  "psi.book.page.exosuit.2": "수트 조각에 사용할 $(thing)주문$(0)을 선택하려면, $(item)레드스톤 가루$(0), $(item)유리$(0) 및 $(l:components/psimetal)$(item)프사이 금속$(0)$(/l)에서 $(item)엑소수트 제어기$(0)를 제작하십시오. $(item)제어기$(0)를 사용하려면 $(thing)프사이 마스터 키바인드$(0)($(k:psimisc.keybind))를 잡습니다.$(p)오른쪽 및 왼쪽 마우스 버튼을 사용하여 수트 조각 사이를 순환합니다.",
  "psi.book.page.exosuit.3": "자비스는 아니지만 효과가 있습니다.",
  "psi.book.page.exosuit.4": "구성할 수트 조각을 선택했으면 $(thing)CAD$(0)와 동일한 방식으로 표시되는 $(l:items/spell_bullet)$(thing)주문 탄환들$(0)$(/l) 중 하나를 선택합니다.$(p)빈 네 번째 슬롯을 선택하면 해당 슬롯에 맞는 항목이 완전히 비활성화됩니다-- 활성화 조건이 충족되더라도 $(thing)주문$(0)이 표시되지 않습니다.",
  "psi.book.page.exosuit.5": "$(thing)프사이 금속 엑소수트$(0)는 $(thing)철 갑옷$(0)보다 강도와 내구성이 약간 뛰어납니다.$(p)수트의 모든 조각은 착용자의 과도한 $(thing)프사이 에너지$(0)로 인해 손상을 복구하게 되며, 이는 착용자가 제작에 사용한 $(l:components/psigem)$(item)프사이 보석$(0)$(/l)에 의해 가능해진 기술입니다.",
  "psi.book.page.exosuit.6": "$(item)프사이 금속 엑소수트 투구$(0)는 $(l:items/exosuit_sensor)$(thing)엑소수트 센서$(0)$(/l)가 트리거할 때마다 설계된 $(thing)주문$(0)을 시전하는 가장 구성하기 쉬운 투구입니다.$(p)$(l:items/exosuit_sensor)$(thing)센서$(0)$(/l)는 제작 그리드에서 $(item)투구$(0)에 부착 및 분리됩니다; $(item)투구$(0)는 한 번에 하나의 $(l:items/exosuit_sensor)$(thing)엑소수트 센서$(0)$(/l)만 부착할 수 있습니다.",
  "psi.book.page.exosuit.7": "소리가 들리면, 돌아서십시오",
  "psi.book.page.exosuit.8": "$(item)프사이 금속 엑소수트 흉갑$(0)은 사용자가 어떤 형태로든 손상을 입을 때마다 선택된 $(thing)주문$(0)을 시전합니다.$(p)$(piece)선택: 공격자$(0)와 $(piece)선택: 입은 데미지$(0)를 사용하여 각각 손상의 원인과 양을 파악할 수 있습니다.",
  "psi.book.page.exosuit.9": "폭발성 가시",
  "psi.book.page.exosuit.10": "$(item)프사이 금속 엑소수트 레깅스$(0)는 선택된 $(thing)주문$(0) 시전을 $(o)멈추지 않습니다$().$(p)실제로, 0.05초와 같은 시간 단위인 $(thing)CAD$(0) 틱당 한 번씩 이 작업을 수행합니다.$(p)그들은 \"더 나은 $(l:items/loopcast_bullet)$(item)반복형 주문 탄환$(0)$(/l)\"으로 꽤 인기가 있습니다.",
  "psi.book.page.exosuit.11": "while(true) {}",
  "psi.book.page.exosuit.12": "$(item)프사이 금속 엑소수트 부츠$(0)는 착용자가 땅에서 뛰어내릴 때 단순히 지정된 $(thing)주문$(0)을 외웁니다.$(p)그 이상도 이하도 아닙니다.",
  "psi.book.page.exosuit.13": "점프 부스터, 부츠",
  "psi.book.entry.exosuitSensor": "엑소수트 센서",
  "psi.book.page.exosuitSensor.0": "$(thing)엑소수트 센서$(0)는 더 큰 갑옷 조각(예: $(l:items/exosuit#helmet)$(item)프사이 금속 엑소수트 투구$(0)$(/l))에 내장되도록 설계된 소형 장치이며, 트리거 시 갑옷이 들어 있는 신호를 보냅니다.$(p)$(thing)센서$(0)마다 트리거되는 요소에 대한 조건이 다릅니다.",
  "psi.book.page.exosuitSensor.1": "모든 $(thing)센서$(0)는 시약 주위에 있는 $(item)철 주괴$(0) 2개와 $(l:components/psimetal)$(item)프사이 금속$(0)$(/l) 2개로 제작됩니다; 사용된 시약은 $(thing)센서$(0)의 효과를 결정합니다:$(p)$(li)$(item)빛 센서$(0)는 $(item)발광석 가루$(0)를 사용하고;$(p)$(li)$(item)열 센서$(0)는 $(item)화염구$(0)를 사용하고;$(p)$(li)$(item)체력 센서$(0)는 $(item)반짝이는 수박$(0)을 사용하고;$(p)$(li)$(item)물 센서$(0)는 $(item)프리즈머린 수정$(0)을 사용하고;$(p)$(li)$(item)뇌관 센서$(0)는 $(item)화약$(0)을 사용합니다.",
  "psi.book.page.exosuitSensor.2": "$(item)엑소수트 빛 센서$(0)는 착용자가 어두운 영역(즉, 몬스터를 생성할 수 있을 만큼 어두운 영역)으로 이동할 때마다 한 번 트리거합니다.$(p)타이머에 $(piece)동작: 광원 소환$(0)이 있는 어두운 영역에서 수동으로 트리거할 수 있습니다.",
  "psi.book.page.exosuitSensor.3": "누가 불 껐어요?",
  "psi.book.page.exosuitSensor.4": "$(item)엑소수트 열 센서$(0)는 착용자에게 불이 붙을 때마다 트리거합니다.$(p)$(piece)동작: 화염 저항$(0) 또는 $(piece)동작: 수맥$(0)은 이 $(thing)센서$(0) 트리거링에 대한 좋은 응답입니다. $(o)실제로$() 무엇을 하고 있는지 모르는 경우입니다.",
  "psi.book.page.exosuitSensor.5": "우리는 계속 가요",
  "psi.book.page.exosuitSensor.6": "$(item)엑소수트 체력 센서$(0)는 착용자의 건강상태가 안 좋을 때(특히 착용자가 심장 3개 이하일 경우) 트리거합니다.$(p)$(piece)동작: 재생$(0)이 이 문제에 대한 좋은 응답일 수 있습니다.",
  "psi.book.page.exosuitSensor.7": "진정하라구요",
  "psi.book.page.exosuitSensor.8": "$(item)엑소수트 물 센서$(0)는 착용자가 물에 닿으면 트리거합니다.$(p)약간의 독창성으로 $(piece)동작: 수맥$(0)을 통해 수동으로 트리거할 수 있습니다.",
  "psi.book.page.exosuitSensor.9": "물 튀기십시오",
  "psi.book.page.exosuitSensor.10": "$(item)엑소수트 뇌관 센서$(0)는 $(l:items/detonator)$(item)주문 뇌관$(0)$(/l)이 32블록 반경 내에서 작동되거나 $(piece)동작: 폭파$(0)가 동일한 영역에 시전될 때마다 트리거합니다.",
  "psi.book.page.exosuitSensor.11": "버튼을 누르면",
  "psi.book.entry.tools": "프사이 금속 도구",
  "psi.book.page.tools.0": "$(thing)프사이 금속 도구$(0)는 $(item)다이아몬드$(0) 티어에 필적하는 일련의 도구로, 의도한 작업을 수행할 때마다 $(thing)주문$(0)을 시전할 수 있습니다.$(p)모든 $(thing)프사이 금속 도구$(0)는 $(item)막대기$(0), $(l:components/psigem)$(item)프사이 보석$(0)$(/l), $(l:components/psimetal)$(item)프사이 금속$(0)$(/l) 대신 $(item)철 주괴$(0)로 제작됩니다.",
  "psi.book.page.tools.1": "보너스 액션입니다.",
  "psi.book.page.tools.2": "$(thing)프사이 금속 도구$(0)는 $(l:basics/cad_assembler)$(item)CAD 조립기$(0)$(/l)에 최대 3개의 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)을 장착할 수 있습니다(일부 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)은 도구과 잘 호환되지 않습니다.).$(p)도구에 사용할 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)을 선택하려면 $(thing)프사이 마스터 키바인드$(0)($(k:psimisc.keybind))를 누른 상태에서 평소처럼 메뉴에서 선택합니다.$(p)메뉴에서 빈 슬롯을 선택하면 도구가 완전히 시전되지 않습니다.",
  "psi.book.page.tools.3": "$(item)프사이 금속 검$(0)을 제외한 모든 $(thing)프사이 금속 도구$(0)는 블록을 깨뜨릴 때마다 선택한 $(thing)주문$(0)을 시전합니다.$(p)대신 $(item)검$(0)은 살아있는 존재에 부딪힐 때마다 던집니다(한번 손상되면, 살아있는 생물은 0.5초 동안 불가침이 된다는 것을 전략적인 목적으로 주목해야 합니다.).$(p)$(thing)프사이 금속 도구$(0)는 휘두르는 사람의 과도한 $(thing)프사이 에너지$(0)를 이용하여 스스로를 수리합니다.",
  "psi.book.page.tools.4": "$(thing)프사이 금속 도구$(0)는 또한 $(thing)주문 조각들$(0)과 편리하게 통합됩니다.$(p)$(item)프사이 금속 검$(0)이 $(thing)주문$(0)을 걸면 $(piece)선택: 대상 공격$(0)은 당신이 때린 몹들을 돌려보냅니다.$(p)다른 $(thing)도구들$(0) 중 하나가 블록을 부수면 $(piece)선택: 부서진 블록$(0)은 부서진 블록의 위치를 반환하고 $(piece)선택: 부서진 블록 측면$(0)은 블록이 부서진 방향에 해당하는 축 벡터를 반환합니다.",
  "psi.book.entry.vectorRuler": "벡터 자",
  "psi.book.page.vectorRuler.0": "$(item)벡터 자$(0)는 임의의 벡터를 저장할 수 있으며, 이 벡터는 사용자가 원할 때 $(thing)주문$(0) 내에서 접근할 수 있습니다.$(p)$(item)철 주괴$(0)와 $(l:components/psidust)$(item)프사이 가루$(0)$(/l)의 끝부분으로 만들어졌습니다.",
  "psi.book.page.vectorRuler.1": "벡터 규칙",
  "psi.book.page.vectorRuler.2": "블록에서 블록의 위치를 벡터로 $(item)자$(0)에 저장하기 위해 ($(k:use)) 웅크린 상태에서 블록에 $(item)자$(0)를 누릅니다.$(p)블록의 위치가 저장되면 다른 블록에 웅크리지 않고 $(item)자$(0)를 누르면 두 블록 사이의 오프셋이 저장됩니다.$(p)$(piece)선택: 벡터 자$(0)를 사용하여 $(item)자$(0)의 저장된 벡터에 접근할 수 있습니다.",
  "psi.book.page.vectorRuler.3": "한 번에 여러 개의 $(item)자$(0)를 가지고 있는 경우 $(piece)선택: 벡터 자$(0)는 핫바에서 가장 왼쪽에 있는 $(item)자$(0)의 저장 값을 반환하고, 핫바에 눈금자가 없으면 인벤토리에서 가장 높은 $(item)자$(0)의 저장 값을 반환합니다.",
  "psi.book.entry.spellDrive": "주문 드라이브",
  "psi.book.page.spellDrive.0": "$(l:components/psimetal)$(item)프사이 금속$(0)$(/l) 주괴 2개와 $(item)레드스톤 가루$(0) 조각으로 만든 $(item)주문 드라이브$(0)는 나중에 사용할 수 있도록 하나의 $(thing)주문$(0)을 저장할 수 있습니다.$(p)$(l:basics/spell_programmer)$(item)주문 프로그래머$(0)$(/l)의 $(thing)주문$(0)을 $(item)드라이브$(0)에 저장하려면 ($(k:use)) 빈 $(item)드라이브$(0)를 웅크리고 문지릅니다.$(p)$(thing)주문$(0)을 다시 복사하려면 $(l:basics/spell_programmer)$(item)프로그래머$(0)$(/l) 위에 저장된 $(thing)주문$(0)을 사용하여 $(item)드라이브$(0)를 쭈그리고 문지릅니다.",
  "psi.book.page.spellDrive.1": "스스로 라이브러리를 만드십시오.",
  "psi.book.page.spellDrive.2": "저장된 $(thing)주문$(0)을 지우려면 $(item)드라이브$(0)를 다른 블록에 대고 쭈그리고 문지릅니다.$(p)저장된 $(thing)주문$(0)이 있는 $(item)드라이브$(0)를 빈 $(item)드라이브$(0) 또는 $(l:items/spell_bullet)$(thing)주문 탄환$(0)$(/l)과 함께 제작 그리드에 배치하여 해당 $(thing)주문$(0)을 후자에 복사할 수 있습니다.",
  "psi.book.category.legacy": "남겨진 항목들",
  "psi.book.category.legacy.desc": "이 항목들은 $(thing)Psi$(0)의 1.12 이전 버전에서의 흔적입니다. 이 책은 다시 작성된 설명서로 채워지기 때문에 모든 설명서가 포팅될 때까지 이 섹션은 크기가 축소됩니다.",
  "psi.book.entry.vectors101": "벡터 101",
  "psi.book.page.vectors101.0": "벡터의 조작은 $(thing)주문$(0) 프로그래밍에 필수적인 요소입니다. 대부분의 벡터 연산은 $(l:basics/vector_primer#ops)여기$(/l)에 간략히 설명되어 있으며 $(piece)연산자: 벡터 가위곱$(0) 부분만 누락되어 있습니다.",
  "psi.book.page.vectors101.1": "두 벡터의 $(l)가위곱$()은 두 벡터에 수직인 벡터입니다. 플레이어의 모양 벡터와 [0, 1, 0]($(piece)연산자: 벡터 가위곱$(0)로 만들 수 있음)의 가위곱을 사용하여 자신의 측면을 가리키는 벡터를 얻을 수 있습니다. ",
  "psi.book.entry.entities101": "엔티티 101",
  "psi.book.page.entities101.0": "엔티티 조작은 $(thing)주문$(0) 프로그래밍에 필수적인 요소입니다. 조작할 수 있는 가장 확실한 실체는 $(piece)선택: 시전자$(0)를 통해 시전자인 당신입니다. 그러나 다른 조각에서는 세상의 다른 엔티티를 대상으로 지정할 수 있습니다.$(p)이러한 조각을 사용하여 다른 엔티티에 영향을 주는 $(thing)주문$(0)을 작성할 수 있습니다. 그것들을 $(piece)동작: 움직임 추가$(0)와 함께 사용하여 다른 사람들을 튕겨보십시오.",
  "psi.book.entry.blockworks": "블록을 다루는 것",
  "psi.book.page.blockworks.0": "블록을 다루는 것은 마법사에게 필수적인 기술입니다. 물론 벡터를 통해 블록의 위치를 참조할 수 있으므로 벡터에 대한 지식은 블록으로 작업하는 방법을 이해하는 데 중요합니다.$(p)이 그룹에서 가장 기본적인 두 블록 조각은 $(piece)동작: 블록 설치$(0)와 $(piece)동작: 블록 파괴$(0)입니다.",
  "psi.book.page.blockworks.1": "이 둘은 위치 벡터를 취하며, 각각 그 위치에 블록을 배치하고 분해합니다. $(piece)동작: 블록 설치$(0)에서는 핫바에서 $(thing)CAD$(0) 오른쪽에 있는 블록을 사용하여 배치합니다. 블록 위치를 깨는 것은 쉽습니다; $(piece)연산자: 벡터 광선 추적$(0)이면 충분합니다.",
  "psi.book.page.blockworks.2": "그러나 블록을 배치하는 것이 더 까다롭습니다: $(piece)연산자: 벡터 광선 추적$(0)은 플레이어가 보고 있는 블록을 우리에게 줍니다. 저기에 블록을 둘 수 없어요-- 이미 $(o)하나$() 있어요! 이를 해결하기 위해, 우리는 $(piece)연산자: 벡터 광선 추적$(0)을 $(piece)연산자: 벡터 축 광선 추적$(0) 조각과 결합할 수 있습니다. 연산자: 벡터 축 광선 추적 조각은 우리가 보고 있는 블록의 측면을 나타내는 벡터를 제공합니다. ",
  "psi.book.page.blockworks.3": "예를 들어, 블록의 상단을 보면 축 벡터 [0, 1, 0]가 나옵니다. $(piece)연산자: 벡터 덧셈$(0)을 사용하여 일반 광선에 추가하여 블록이 어디로 가는지 알 수 있습니다!$(p)$(piece)연산자: 엔티티의 축 시선$(0)은 $(piece)연산자: 엔티티의 시선$(0)과 유사하지만 6개의 축 벡터 중 하나로 스냅된 값을 반환합니다(예: 동쪽을 보는 경우 [1, 0, 0]). F3 메뉴의 \"대면\" 값을 생각해 보십시오.",
  "psi.book.page.blockworks.4": "여기서 사용할 수 있는 다른 두 가지 $(thing)동작$(0)은 $(piece)동작: 블록 묶음 설치$(0)와 $(piece)동작: 블록 묶음 파괴$(0)입니다. 이러한 $(thing)동작$(0)은 블록을 부수거나 블록을 배치합니다. 표준 파괴 및 설치 $(thing)동작$(0)과 마찬가지로, 이들은 시작할 위치가 필요하지만, 조작 방향을 정의하는 또 다른 벡터 \"대상\"이 필요합니다. 따라서 \"대상\"이 [0, 1, 0]이면 \"위치\" 값부터 시작하여 블록을 위쪽으로 배치하거나 끊습니다.",
  "psi.book.page.blockworks.5": "이러한 $(thing)동작$(0)의 마지막 구성요소는 \"최대\"이며, $(thing)동작$(0)이 깨지거나 배치될 수 있는 최대 블록 양에 대한 숫자 상수입니다. 벡터 요구사항이 일정하지 않기 때문에, 이것은 $(thing)동작$(0)의 효력과 비용을 계산하는 수단으로 작용합니다. 높게 설정할수록 $(thing)주문$(0) 비용이 높아집니다.$(p)이 그룹의 마지막 조각은 $(piece)연산자: 벡터 투영$(0)입니다.",
  "psi.book.page.blockworks.6": "벡터 투영법은 다소 복잡한 주제이므로 아래에서 잠재적인 용도를 설명하겠습니다.$(p)세상 속 자신의 위치에서 보고 있는 위치로 블록을 배치하되, 보고 있는 블록의 측면에 일직선으로 배치하는 $(thing)주문$(0)을 만들고 싶다고 가정합니다($(piece)연산자: 벡터 축 광선 추적$(0) 사용).",
  "psi.book.page.blockworks.7": "먼저 블록을 배치할 벡터를 찾아서 $(piece)동작: 블록 묶음 설치$(0)에 연결할 수 있습니다. 그러나 블록에 대각선이 되면 [3, 2, 4]와 같은 결과를 얻을 수 있습니다. 직선이 아닙니다! $(piece)연산자: 벡터 투영$(0)을 사용하여 여러분이 보고 있는 측면의 축에 [0, 0, 1]을 투영할 수 있습니다.",
  "psi.book.page.blockworks.8": "따라서 \"벡터 A\"는 [3, 2, 4]이고 \"벡터 B\"는 [0, 0, 1]입니다. 예측을 적용하면 [0, 0, 4]가 남습니다. 예를 들어 \"벡터 B\"가 [1, 0, 0]이면 [3, 0, 0]이 됩니다. 일반적으로 축 벡터가 \"벡터 B\"에 사용될 때 $(piece)연산자: 벡터 투영$(0)은 B에서 0인 A의 성분을 모두 벗겨내고 직선을 남깁니다.$(p)이 모든 것을 종합하기 위해, 여러분은 8블록 높이의 기둥을 무너뜨리는 $(thing)주문$(0)을 만들어 보세요, 그러면 여러분은 \"떨어지게\" 될 것입니다!",
  "psi.book.entry.movementAdvances": "이동 진행",
  "psi.book.page.movementAdvances.0": "$(piece)동작: 움직임 추가$(0)에 대해 이야기할 때 움직임의 기본 $(thing)동작$(0)에 대해 다루었습니다. 이 그룹은 그 아이디어를 개선해 주는 조각들을 가지고 있습니다.$(p)$(piece)동작: 점멸$(0)은 단순히 목표물을 그들이 보고 있는 방향으로 텔레포트합니다. 음수 값은 엔티티를 뒤로 순간이동합니다.",
  "psi.book.page.movementAdvances.1": "$(piece)동작: 전체 점멸$(0)은 $(piece)동작: 점멸$(0)와 동일하게 적용하되, 대신에 엔티티 목록을 수락합니다; 목록의 각 엔티티는 $(thing)동작$(0)의 영향을 받습니다.$(p)$(piece)동작: 전체 움직임 추가$(0)도 비슷합니다; 그것은 $(piece)동작: 움직임 추가$(0)의 엔티티 목록 버전입니다.$(p)마지막으로, $(piece)동작: 전체 집결$(0)은 엔티티 목록의 모든 엔티티를 지정된 속도로 지정된 위치로 당깁니다. 음의 속도는 대신 그들을 밀어낼 것입니다. ",
  "psi.book.entry.blockMovement": "블록 이동",
  "psi.book.page.blockMovement.0": "블록을 이동하는 능력은 블록을 부수고 배치하는 기능만큼 중요하지는 않지만, 그럼에도 불구하고 매우 유용합니다.$(p)$(piece)동작: 블록 이동$(0)은  블록이 피스톤에 의해 밀리는 것처럼 블록의 위치를 잡고 대상 벡터의 방향으로 이동합니다. 목표 벡터는 축이어야 하며 그렇지 않으면 $(thing)동작$(0)이 실패합니다.",
  "psi.book.page.blockMovement.1": "반면에 $(piece)동작: 블록 무너뜨리기$(0)는 모래나 자갈처럼 블록이 떨어지게 합니다.$(p)두 가지 $(thing)동작$(0) 모두 복잡한 블록(타일 엔티티라고 함)과 섬세한 손길로 수집할 수 없는 블록에서 실행되지 않습니다. ",
  "psi.book.entry.elementalArts": "기초 마법",
  "psi.book.page.elementalArts.0": "$(thing)주문$(0)을 외울 능력이 없는 마법 시스템이 뭐죠?$(p)이 그룹은 4가지 요소에 대한 $(thing)주문$(0)을 포함합니다; 예를 들어, $(piece)동작: 번개$(0)는 지시된 위치의 번개를 호출합니다.",
  "psi.book.page.elementalArts.1": "그룹에는 0(포함)과 전달된 숫자(포함) 사이의 임의 숫자를 생성하는 $(piece)연산자: 임의의 값$(0)도 포함됩니다. 이것은 반복형 또는 주문 원 $(thing)주문$(0)과 함께 여러 가지 방법으로 사용할 수 있습니다. 예를 들어, $(piece)동작: 급성장$(0)을 사용하여 플랜테이션에서 뼈를 대량으로 사용하는 $(thing)주문$(0)을 생성할 수 있습니다. ",
  "psi.book.entry.positiveEffects": "장점",
  "psi.book.page.positiveEffects.0": "사물과 사람에 마법 효과를 적용하는 능력은 그것의 무게만큼 가치가 있는 마법 어휘의 필수적 특징입니다.주문책에서 $(thing)주문$(0)을 작성하지는 않지만 엔티티에 효과를 적용할 수 있습니다.$(p)이 그룹의 모든 조각은 지정된 시간(초) 동안 각각의 물약 효과를 대상 엔티티에 적용합니다.",
  "psi.book.page.positiveEffects.1": "조각에 힘 매개 변수가 있는 경우 적용할 효과의 수준을 나타냅니다.$(p)예를 들어, 시간 20과 힘 2인 $(piece)동작: 신속$(0)은 20초 동안 신속 II 효과를 대상 엔티티에 적용합니다. ",
  "psi.book.entry.negativeEffects": "단점",
  "psi.book.page.negativeEffects.0": "예상할 수 있듯이 $(l:legacy/positive_effects)장점$(/l)은 단점을 가져옵니다.$(p)여기선 할 말이 별로 없습니다. 이 그룹의 모든 동작은 그들이 말한 그대로 깡통에 담습니다.$(p)즐겁게 보내십시오. ",
  "psi.book.entry.trigonometry": "삼각법",
  "psi.book.page.trigonometry.0": "이 그룹에는 삼각 함수와 관련된 $(thing)연산자$(0)가 포함됩니다. $(piece)상수: 원주율(π)$(0)은 주석에 표시된 것과 정확히 같으며, 이 상수는 \u03c0=3.1415\u2026의 값을 제공합니다.$(p)이 그룹에는 사인(sin) 및 코사인(cos) 함수와 역수(아크사인(arcsin) 및 아크코사인(arccos))와 같은 기본 삼각 연산도 포함됩니다.",
  "psi.book.page.trigonometry.1": "또한, $(piece)연산자: 스칼라곱$(0)은 두 벡터의 점 곱을 반환합니다: 두 벡터의 크기의 곱에 그들 사이의 각도의 코사인을 곱합니다. 결과에 $(piece)연산자: 아크 코사인$(0)을 사용하면 두 벡터 사이의 각도를 얻을 수 있습니다. ",
  "psi.book.entry.smeltery": "제련",
  "psi.book.page.smeltery.0": "이 그룹에 속한 조각들은 매우 단순하게 작동합니다; 마치 화로에 넣은 것처럼 모든 것을 다른 물건에 녹여 넣었습니다.$(p)$(piece)동작: 아이템 제련$(0)은 세계에 떨어진 한 개의 아이템을 제련된 아이템으로 요리할 것입니다.",
  "psi.book.page.smeltery.1": "$(piece)동작: 블록 제련$(0)은 세상의 한 블록을 제련된 형태로 만들 것입니다. 제련된 형태도 블록이라면 말이죠.$(p)그래서 조약돌을 녹여 돌로 만든 다음 매끄러운 돌로 만들 수 있지만, 나무가 목탄으로 향을 낼 수 없습니다. ",
  "psi.book.entry.flowControl": "흐름 제어",
  "psi.book.page.flowControl.0": "흐름 제어는 다소 복잡한 주제입니다. 여기에 포함된 모든 조각은 $(thing)주문$(0)이 매우 다양한 방식으로 작동할 수 있도록 합니다. 그러나 이러한 조각을 올바르게 사용하는 방법을 이해하려면 주문 시전 시스템의 내부 정보에 대한 지식이 필요합니다-- 자세한 내용은 $(l:basics/eval_order)이 문단$(/l)을 읽어보십시오.",
  "psi.book.page.flowControl.1": "그 정보를 가지고 $(piece)동작: 미루기$(0)부터 시작하겠습니다. 이 조각으로 인해 시전된 $(thing)주문$(0)이 틱의 수만큼 실행이 지연됩니다. (틱은 0.05초의 범위입니다.) 따라서 $(thing)주문$(0) 처리를 0.5초 지연시키려면 10을 \"시간\" 매개변수로 사용합니다. $(piece)동작: 미루기$(0)는 $(thing)주문$(0)에 $(l:basics/tutorial_5#projection)$(thing)투영$(0)$(/l)을 추가하지 않지만 $(l:basics/tutorial_5#potency)$(thing)효능$(0)$(/l) 비용이 듭니다.",
  "psi.book.page.flowControl.2": "$(piece)동작: 값 구하기$(0)는 아무것도 하지 않는 $(thing)동작$(0)입니다.$(p)네, 잘 들으셨습니다. 이 $(thing)동작$(0)은 아무것도 안 합니다. $(thing)주문$(0)통계에도 추가되지 않습니다.$(p)$(piece)동작: 미루기$(0)가 실행되기 전에 값을 평가하여 $(piece)동작: 미루기$(0)가 트리거되기 전의 엔티티를 나중에 $(thing)주문$(0)에서 사용할 수 있습니다.",
  "psi.book.page.flowControl.3": "반면에 $(piece)동작: 죽기$(0)는 용어의 적절한 의미에서 흐름 제어 조각입니다.$(p)숫자 매개 변수가 필요하며, 이 숫자의 절대값이 1보다 완전히 낮은 경우(배타적) $(thing)주문$(0)이 즉시 사라집니다. $(thing)동작$(0)에 전달된 다른 값을 사용하면 평소처럼 $(thing)주문$(0)이 계속됩니다.$(p)이 조각은 $(l:basics/tutorial_5#projection)$(thing)투영$(0)$(/l)을 필요로 하지 않습니다.",
  "psi.book.page.flowControl.4": "$(piece)동작: 죽기$(0)를 사용하는 매우 간단한 방법은 $(piece)선택: 웅크림 여부$(0)와 결합하는 것으로 시전자가 몰래 접근하면 0이 되고 그렇지 않으면 1이 반환됩니다.$(p)그 이유는 거의 다 같이 사용하기 위해 만들어진 것 같기 때문입니다!",
  "psi.book.page.flowControl.5": "$(piece)상수: 변환기$(0)에서는 숫자 상수가 필요하지 않은 $(thing)동작$(0)에 대한 숫자를 반환하는 조각을 사용할 수 있습니다.$(p)이제 $(thing)동작$(0)에 입력되는 숫자 상수는 $(thing)주문$(0)이 시전되기 전에 $(thing)주문$(0)의 통계($(l:basics/tutorial_5#cost)$(thing)비용$(0)$(/l) 포함)를 계산하는 데 사용됩니다.$(p)이러한 상수는 컴파일 타임에 필요하므로 실행 타임에 평가되는 단순한 숫자는 여기서 사용할 수 없습니다.",
  "psi.book.page.flowControl.6": "$(piece)상수: 변환기$(0)는 두 개의 숫자(상수 및 비상수)를 허용하여 이 문제를 해결합니다.$(p)조각에 전달된 상수는 $(thing)주문$(0)컴파일 계산에 사용되지만 비상수 번호는 $(thing)주문$(0)이 실제로 실행될 때 사용됩니다.$(p)비상수 번호 값은 $(thing)주문$(0) 실행 중 상수 값으로 제한되므로 실수 발생을 방지할 수 있습니다.",
  "psi.book.page.flowControl.7": "실행 시간 번호는 두 숫자의 기호가 일치하도록 숫자 상수의 기호로 변경되었습니다. 상수 번호가 0이면 $(piece)상수: 변환기$(0)는 입력에 관계없이 항상 0을 반환합니다.",
  "psi.book.entry.blockConjuration": "블록 소환",
  "psi.book.page.blockConjuration.0": "이 그룹에는 알려드린 대로 정확하게 작동하는 조각들이 포함됩니다: 그것들은 블록을 만들어 냅니다.$(p)$(piece)동작: 블록 소환$(0)에서는 지정된 위치에 반투명 고체 블록인 소환된 블록을 생성합니다. \"시간\" 매개변수와 함께 사용할 경우 지정된 시간이 경과한 후 소환된 블록이 조용히 부서질 수 있습니다.",
  "psi.book.page.blockConjuration.1": "\"시간\" 매개변수가 사용되는 경우 틱(0.05초 단위)으로 지정됩니다. 따라서 0.5초 후에 사라지는 블록을 만들려면 \"시간\" 매개변수를 10틱으로 설정합니다.$(p)$(piece)동작: 광원 소환$(0)은 충돌할 수 없는 광원을 대신 소환하게 됩니다.",
  "psi.book.page.blockConjuration.2": "$(piece)동작: 블록 묶음 소환$(0)은 $(piece)동작: 블록 묶음 설치$(0)와 같은 기능을 하지만 대신 소환된 블록을 생성합니다. 이 두 조각 모두 \"시간\"  매개 변수를 포함합니다.$(p)소환된 블록은 깨지기 쉬우므로 플레이어가 휘두르려고 하는 모든 도구에 즉시 파손됩니다.",
  "psi.book.entry.eidosManipulation": "형상 조작",
  "psi.book.page.eidosManipulation.0": "형상 $(thing)동작$(0)은 시전자가 시공간 연속체를 자신들에게 유리하게 조작할 수 있게 해줍니다.$(p)$(piece)동작: 형상 회귀$(0)는 해당 시전자가 지정된 시간(초) 동안 두 배의 속도로 역방향으로 스텝을 추적하도록 합니다.",
  "psi.book.page.eidosManipulation.1": "한 번에 하나의 형상 회귀만 활성화될 수 있으며, 회귀를 시전한 후에는 모든 후속 회귀는 마지막 회귀가 끝난 위치로만 되돌릴 수 있습니다. 슬쩍하면 진행 중인 회귀가 중지됩니다.$(p)그룹의 다른 $(thing)동작$(0) 조각인 $(piece)동작: 형상의 닻$(0)은 시전자를 위한 \"닻\"을 만듭니다.",
  "psi.book.page.eidosManipulation.2": "지정된 시간(초)이 지나면 시전자가 뒤틀려 닻 위치로 돌아갑니다. $(piece)동작: 형상의 닻$(0)은 여러 번 연속적으로 빠르게 실행될 수 있지만 마지막으로 생성된 닻만 활성화됩니다.",
  "psi.book.page.eidosManipulation.3": "마지막으로, $(piece)선택: 형상 체인지로그$(0)은 단일 숫자 매개 변수(n이라고 부름)를 취하고, 끝에서부터 시작하는 형상 체인지로그의 n번째 인덱스에서 위치를 제공합니다. 즉, n개 틱에 대한 위치 벡터를 제공합니다.$(p)$(piece)동작: 형상 회귀$(0)는 당신을 뒤쪽으로 이동시켜 \"뒤로\" 발생하는 모든 위치를 쓸어버립니다. $(piece)동작: 형상의 닻$(0)는 체인지로그를 수정하지 않습니다. ",
  "psi.book.entry.detectionDynamics": "감지 및 초점",
  "psi.book.page.detectionDynamics.0": "이 그룹에는 제목에 따라 감지 및 초점의 두 가지 유형이 포함됩니다. 이를 이해하려면 슬롯 초점의 개념을 도입해야 합니다.",
  "psi.book.page.detectionDynamics.1": "슬롯 초점의 이미 알려진 예는 설치 블록 방식의 $(thing)동작$(0)입니다. $(thing)CAD$(0) 오른쪽에 있는 블록을 바로 사용합니다. 슬롯 초점은 이와 같은 $(thing)동작$(0)이 사용할 슬롯입니다. 이 값은 $(thing)CAD$(0) 위치에 상대적이거나 절대적일 수 있으며, 핫바에만 있을 수 있으며 1에서 9까지입니다.",
  "psi.book.page.detectionDynamics.2": "기본적으로 $(thing)주문$(0)이 지정될 때마다 해당 값은 \"상대 1\"이므로 $(thing)CAD$(0) 오른쪽에 1 슬롯이 됩니다. \"상대 -1\"이면 $(thing)CAD$(0) 왼쪽에 1개의 슬롯이 됩니다. \"절대 3\"이 핫바에서 세 번째 슬롯이 될 것입니다. 또한 마지막 슬롯에 $(thing)CAD$(0)가 있고 값이 \"상대 1\"이면 첫 번째 슬롯이 됩니다.",
  "psi.book.page.detectionDynamics.3": "집중된 슬롯은 $(piece)동작: 선택 슬롯 변경 (핫바)$(0)을 사용하여 설정할 수 있습니다. 이 작업은 두 개의 매개 변수 중 하나를 사용합니다. 둘 다 선택 사항이며 상호 배타적이므로 정의하지 않으면 초점이 \"상대 1\"의 기본값으로 설정됩니다. \"위치\" 매개변수를 설정할 경우 절대값이 설정되지만 \"이동\" 파라미터는 상대적 값을 설정합니다.",
  "psi.book.page.detectionDynamics.4": "이를 통해 상황에 따라 서로 다른 블록으로 물건을 만들 수 있습니다. 이 $(thing)동작$(0)은 현재 $(thing)주문$(0) 시전에만 적용되며, 다음 번에 같은 $(thing)주문$(0)이라도(비록 같은 $(thing)주문$(0)일지라도) 시전할 때 초점이 재설정됩니다.$(p)그룹의 나머지 두 조각은 \"감지\" 영역에 설정됩니다.",
  "psi.book.page.detectionDynamics.5": "먼저 $(piece)선택: 아이템 존재$(0)는 슬롯 번호(선택 사항으로 설정되지 않으면 집중된 슬롯으로 기본 설정됨)를 선택한 후 슬롯에 있는 아이템 수(비어 있으면 0)를 반환합니다.",
  "psi.book.page.detectionDynamics.6": "마지막으로, $(piece)선택: 블록 존재$(0)는 벡터를 취하여 전 세계에서 좌표로 사용하고, 블록에서 블록을 찾으면 반환되는 값은 블록이나 교체 가능한 블록(키 큰 잔디 등)이 없으면 0이고, 고체 블록이 아닌 경우 1, 고체 블록인 경우 2입니다. ",
  "psi.book.entry.memoryManagement": "메모리 관리",
  "psi.book.page.memoryManagement.0": "이 그룹은 $(thing)CAD$(0) 내부에 정보를 지속적으로 저장할 수 있는 $(thing)주문$(0) 기능을 소개합니다. $(thing)CAD$(0)는 이후 $(thing)주문$(0)실행 시 검색할 벡터를 저장할 수 있습니다. $(thing)CAD$(0)는 $(l:components/socket)$(thing)소켓$(0)$(/l) 슬롯 3개당 벡터 1개를 저장할 수 있습니다.",
  "psi.book.page.memoryManagement.1": "$(thing)CAD$(0)가 저장할 수 있는 벡터의 수를 $(thing)메모리 슬롯$(0)의 수라고 합니다.$(p)이 조각 그룹에는 $(thing)CAD$(0)의 $(thing)메모리 슬롯$(0)에서 벡터를 저장하고 로드할 수 있는 두 개의 $(thing)주문 조각$(0)이 포함됩니다.$(p)$(piece)동작: 벡터 저장$(0)은 지정된 $(thing)메모리 슬롯$(0)에 벡터를 저장하고 $(piece)선택: 저장된 벡터$(0)는 지정된 $(thing)메모리 슬롯$(0)에 저장된 벡터를 검색합니다.",
  "psi.book.page.memoryManagement.2": "$(thing)CAD$(0)의 $(thing)메모리 슬롯$(0)은 1부터 번호가 매겨지므로 메모리 슬롯이 3개인 $(thing)CAD$(0)는 슬롯 1, 2, 3에 저장할 수 있습니다.$(p)이 그룹의 두 가지 $(thing)동작$(0)은 사용된 슬롯 수와 동일한 $(thing)주문$(0)에 $(l:basics/tutorial_5#potency)$(thing)효능$(0)$(/l)을 추가합니다.$(p)예를 들어 슬롯 2에 저장하거나 슬롯 2에서 로드하려면 두 개의 $(l:basics/tutorial_5#potency)$(thing)효능$(0)$(/l)이 필요합니다.",
  "psi.book.page.memoryManagement.3": "$(piece)동작: 벡터 저장$(0)에는 불완전성이 있습니다: 저장된 $(thing)메모리 슬롯$(0)을 \"잠금\"합니다.$(p)이렇게 하면 두 조각 중 하나가 나중에 $(thing)주문$(0)에서 동일한 $(thing)메모리 슬롯$(0)과 상호 작용하는 것을 방지할 수 있습니다.$(p)따라서 슬롯에 새로운 내용을 저장하기 전에 슬롯에 저장된 값을 로드해야 하는 경우 저장 전에 부하가 발생하도록 흐름 제어 규칙을 기억해야 합니다.",
  "psi.book.entry.secondaryOperators": "보조 연산자",
  "psi.book.page.secondaryOperators.0": "이름에서 알 수 있듯이, 이 그룹은 덧셈이나 뺄셈과 같은 \"1차\" $(thing)연산자$(0)만큼 중요하지 않은 수학적 연산자로 구성되어 있습니다. 이 그룹은 $(thing)주문$(0) 생성에 도움이 되는 조각과 관련이 있는 모든 종류의 수학 또는 논리로 구성된 혼합된 가방일 뿐입니다. 설명을 쉽게 하기 위해 조각을 두 세트로 나누겠습니다.",
  "psi.book.page.secondaryOperators.1": "첫 번째 세트는 $(piece)연산자: 제곱$(0), $(piece)연산자: 거듭제곱$(0), $(piece)연산자: 제곱근$(0), $(piece)연산자: 로그$(0)와 같은 조각들을 포함하여 숫자를 제곱하는 것과 관련이 있습니다. 대부분은 당신이 예상한 대로 작동합니다.$(p)$(piece)연산자: 로그$(0)는 기본 인수(선택 사항)를 사용합니다; 기본이 전달되지 않으면 기본값은 10입니다.$(p)$(piece)상수: e$(0)는 자연 로그를 얻는 데도 사용할 수 있습니다.",
  "psi.book.page.secondaryOperators.2": "두 번째 $(thing)연산자$(0) 세트는 논리와 관련이 있습니다. (정수로) 반올림하는 조각입니다.$(p)$(piece)연산자: 올림$(0), $(piece)연산자: 내림$(0), $(piece)연산자: 반올림$(0)은 각각 위, 아래 및 가장 가까운 정수로 반올림합니다.$(p)이 그룹에는 $(piece)연산자: 최솟값$(0)과 $(piece)연산자: 최댓값$(0)도 포함됩니다. 각 모수의 크기가 가장 작고 큽니다."
}
